/**
	Copyright Â© 2020 Oleh Ihorovych Novosad (Novossaad)
*/

///////////////////////////////////////////////////////////////////////////////
// Init, create and destroy

L_Node l_node_create(Mem_Arr mem_arr, lu_p_void value)
{
	L_Node node = (L_Node) mem_arr_item_alloc(mem_arr);

	l_node_init(node, value);

	return node;
}

void l_node_destroy(Mem_Arr mem_arr, L_Node* l_node)
{
	//list_destroy_all(&(*l_node)->values);
	mem_arr_item_free(mem_arr, (lu_p_void) *l_node);
	*l_node = NULL;
}

List list_create(Mem mem, lu_size max_size_in_items)
{
	List self 			= (List) mem_alloc(mem, sizeof(struct list));
	Mem_Arr mem_arr 	= mem_arr_create(
		mem, 
		sizeof(struct l_node),
		max_size_in_items,
		0,
		MEM_ARR_ITEM_FREEABLE
	);

	lu_assert(mem_arr != NULL);

	// Initialize
	return list_init(self, mem_arr, max_size_in_items);
}

///////////////////////////////////////////////////////////////////////////////
// Main public methods

L_Node list_attach(List self, L_Node node)
{
	L_Node last = self->last;
	
	if (last) 
	{
		last->next = node;
		node->prev = last;
	}

	self->last = node;
	if (self->first == NULL) self->first = self->last;

	++self->count;

	return node;
}

L_Node list_append(List self, lu_p_void value)
{
	L_Node node = l_node_create(self->mem_arr, value);
	
	list_attach(self, node);

	return node;
}

L_Node list_prepend(List self, lu_p_void value)
{
	L_Node node 	= l_node_create(self->mem_arr, value);
	L_Node first = self->first;
	
	if (first) 
	{
		first->prev = node;
		node->next 	= first;
	}

	self->first = node;
	if (self->last == NULL) self->last = self->first;

	++self->count;

	return node;
}

L_Node list_detach(List self, L_Node node)
{
	lu_assert(node != NULL);

 	L_Node prev = node->prev;
 	L_Node next = node->next;

 	if (node == self->first) self->first = next;
 	if (node == self->last) self->last = prev;

 	if (next) next->prev = prev;
 	if (prev) prev->next = next;

 	--self->count;

 	return node;
}

void list_remove(List self, L_Node node)
{ 
	list_detach(self, node);

 	l_node_destroy(self->mem_arr, &node);
}

L_Node list_insert_after(List self, lu_p_void value, L_Node node)
{
	return NULL;	
}
 
L_Node list_insert_before(List self, lu_p_void value, L_Node node)
{ 
	return NULL;
}

L_Node list_replace(List self, lu_p_void value, L_Node node)
{ 
	return NULL;
}

L_Node list_find_forward(List self, lu_fp_is_value block)
{ 
	L_Node current = self->first;

	while (current)
	{
		if (block(current->value)) return current;

		current = current->next;
	}

	return NULL;
}

L_Node list_find_backward(List self, lu_fp_is_value block)
{
	L_Node current = self->last;

	while (current)
	{
		if (block(current->value)) return current;

		current = current->prev;
	}

	return NULL;
}

void list_batch_append(List self, lu_p_void value, lu_size count)
{
	for (lu_size i = 0; i < count; i++)
	{
		list_append(self, value);
	}
}

void list_destroy_all(List self)
{
	L_Node curr = self->first;
	L_Node to_dest;
	while (curr)
	{
		to_dest = curr;
		curr 	= curr->next;

		l_node_destroy(self->mem_arr, &to_dest);
	}			
}

void list_each(List self, void (*block)(List, L_Node, lu_p_void p1), lu_p_void p1)
{
	L_Node curr = self->first;
	L_Node to_dest;
	while (curr)
	{
		to_dest = curr;
		curr 	= curr->next;

		block(self, to_dest, p1);
	}	
}

///////////////////////////////////////////////////////////////////////////////
// Other public methods

