/**
	Copyright Â© 2020 Oleh Ihorovych Novosad 
*/

 
///////////////////////////////////////////////////////////////////////////////
// Inits, create and destroy

	Mem_Arr mem_arr_create (
		Mem 			mem, 
		lu_size 		item_size, 
		lu_size 		size, 
		lu_value 		percent,
		lu_flags 		flags
	)
	{
		if (item_size == 0) return NULL;

		if (size == 0 && percent == 0) return NULL;

		if (percent > 100.0) return NULL;

		if (size == 0 && percent > 0)
		{
			// x * ps + x * is + sisa = a
			// x * (ps + is) = a - sisa
			// x = (a - sisa)/(ps + is)

			lu_size a = mem_avail(mem) * percent  / 100.0;

			lu_size fis = item_size;
			if (flags & MEM_ARR_ITEM_FREEABLE) 
				fis += sizeof(lu_p_byte);

			size = (a - sizeof(struct mem_arr)) / fis;
		}

		lu_size full_size = sizeof(struct mem_arr) + item_size * size;
		
		if (flags & MEM_ARR_ITEM_FREEABLE) 
			full_size += sizeof(lu_p_byte) * size;


		lu_p_byte start = mem_alloc(mem, full_size);

		if (start == NULL) return NULL;

		Mem_Arr self 			= (Mem_Arr) start;
		self->item_size 		= item_size;
		self->size 				= size;
		self->flags 			= flags;
		self->items_start 		= start + sizeof(struct mem_arr);
		self->items_pos			= self->items_start;
		self->items_end			= self->items_start + self->size * self->item_size;
		self->free_start 		= (lu_p_byte*) self->items_end;
		self->items_count 		= 0;
		self->free_count		= 0;

		return self;
	}

///////////////////////////////////////////////////////////////////////////////
// Main methods

	lu_p_byte mem_arr_item_alloc(Mem_Arr self)
	{
		lu_p_byte res;
		if (self->items_pos < self->items_end)
		{
			res = self->items_pos;
			self->items_pos += self->item_size;
		}
		else 
		{
			if (self->free_count <= 0)
				return NULL; // out of available memory

			res = self->free_start[--self->free_count];
		}

		++self->items_count;

		return res;
	}

	void mem_arr_item_free(Mem_Arr self, lu_p_byte item)
	{
		if (item == NULL) return;  // should prob debug this

		if (!(self->flags & MEM_ARR_ITEM_FREEABLE)) return;

		lu_assert(self->items_count > 0);
		lu_assert(self->free_count < self->size); 

		self->free_start[self->free_count++] = item;

		--self->items_count;
	}


