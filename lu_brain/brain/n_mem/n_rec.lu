/**
	Copyright Â© 2020 Oleh Ihorovych Novosad 
*/



	
	// static N_Rec n_rec_create(N_Mem n_mem, Lu_Rec rec)
	// {
	// 	lu_user_assert(n_mem, "N_Mem is NULL");
	// 	lu_user_assert(n_mem->brain, "n_mem->brain is NULL");
	// 	lu_user_assert(rec, "Rec is NULL");

	// 	Mem mem = n_mem->brain->mem_perm;

	// 	;

	// 	lu_user_assert(rec->width > 0, "Rec width is 0");
	// 	lu_user_assert(rec->height > 0, "Rec height is 0");

	// 	// N_Rec self 			= (N_Rec) mem_alloc(mem, sizeof(struct n_rec));
	// 	// lu_user_assert(self, "Cannot allocate N_Rec");

	// 	// lu_size self->colors_w;
	// 	// lu_size self->colors_h;

	// 	// if (rec->width == 1)
	// 	// 	self->colors_w = 1;
	// 	// else 
	// 	// 	self->colors_w = (lu_size) lu_value_round(((lu_value) rec->width) / 2.0);

	// 	// if (rec->height == 1)
	// 	// 	self->colors_h = 1;
	// 	// else
	// 	// 	self->colors_h = (lu_size) lu_value_round(((lu_value) rec->height) / 2.0);

	// 	// self->n_cols = (N_Col*) mem_alloc(
	// 	// 	mem, 
	// 	// 	sizeof(N_Col) * (rec->width + self->colors_w) * (rec->height * self->colors_h)
	// 	// );

	// 	// lu_user_assert(self->n_cols, "Cannot allocate N_Rec n_cols");

	// 	return self;
	// }

	static void n_rec_debug_print(N_Rec self)
	{
		lu_debug("\n---------------------");
		lu_debug("\nn_cols: ");
		lu_size x, y;
		N_Col col;
		for(y = 0; y < self->n_cols_h; y++)
		{
			lu_debug("\n");
			for(x = 0; x < self->n_cols_w; x++)
			{
				col = n_rec_n_cols_get(self, x, y);

				if (col == NULL)
					lu_debug(" ");
				else
				{
					switch(col->type)
					{
						case NCT_COL:
							lu_debug("c");
							break;
						case NCT_PER:
							lu_debug("p");
							break;
						case NCT_PER_DIAG:
							lu_debug("x");
							break;
						default:
							lu_debug("ERROR");
					}
				} 
			}
		}

		lu_debug("\n---------------------");
		lu_debug("\ncolors: ");

		for(y = 0; y < self->colors_h; y++)
		{
			lu_debug("\n");
			for(x = 0; x < self->colors_w; x++)
			{
				col = n_rec_colors_get(self, x, y);

				if (col == NULL)
					lu_debug("NULL ");
				else if (col->type != NCT_COL)
					lu_debug("ERROR ");
				else
					lu_debug("(%d, %d) ", col->x, col->y);
			}
		}  

		lu_debug("\n");
	}

	static N_Rec n_rec_create(N_Mem n_mem, Lu_Rec rec)
	{
		lu_user_assert(n_mem, "N_Mem is NULL");
		lu_user_assert(n_mem->brain, "n_mem->brain is NULL");
		lu_user_assert(rec, "Rec is NULL");
		lu_user_assert(rec->max_value > rec->min_value, "Lu_Rec max_value should be greater than Lu_Rec min_value");
		lu_user_assert(rec->val_ssp > 0 && rec->val_ssp <= 0.5, "Lu_Rec val_ssp should be greater than 0 and less equal to 0.5");

		Mem mem = n_mem->brain->mem_perm;

		lu_user_assert(mem, "Mem is NULL");

		N_Rec self = (N_Rec) mem_alloc(mem, sizeof(struct n_rec));
		lu_user_assert(self, "Cannot allocate N_Rec");

		self->component_size 	= rec->component_size;
		self->colors_w 			= rec->width;
		self->colors_h 			= rec->height;

		// self->colors_w = 10;
		// self->colors_h = 10;

		// Initialize
		self->n_mem			= n_mem;
		self->rec 			= rec;

		if (rec->width == 1)
			self->pers_w = 0;
		else 
			self->pers_w = self->colors_w - 1;

		if (rec->height == 1)
			self->pers_h = 0;
		else
			self->pers_h = self->colors_h - 1;

		//lu_debug("\npers_w = %d, pers_h = %d \n", self->pers_w, self->pers_h);

		self->n_cols_w 			= self->colors_w + self->pers_w;
		self->n_cols_h			= self->colors_h + self->pers_h;

		self->n_cols = (N_Col*) mem_alloc(
			mem, 
			sizeof(N_Col) * self->n_cols_w * self->n_cols_h 
		);

		lu_user_assert(self->n_cols, "Cannot allocate n_cols");

		self->colors = (N_Col*) mem_alloc(
			mem,
			sizeof(N_Col) * self->colors_w * self->colors_h
		);

		lu_user_assert(self->colors, "Cannot allocate colors");

		self->val_neu_size  = rec->val_neu_size; // value depth in indexes
		self->orig_min_val 	= rec->min_value;
		self->orig_max_val 	= rec->max_value;
		self->max_val 		= self->orig_max_val - self->orig_min_val;
		self->val_step 		= self->max_val / (lu_value) self->val_neu_size;
		self->val_ssp_i 	= (lu_size) lu_value_round(self->max_val * rec->val_ssp / self->val_step); // ssp in indexes

	 	// Kroky preobchysleni
		self->val_steps = (lu_value*) mem_alloc(mem, sizeof(lu_value) * self->val_neu_size);
		lu_user_assert(self->val_steps, "Cannot allocate val_steps");
		
		lu_size i;
		for (i = 0; i < self->val_neu_size; i++)
			self->val_steps[i] = (lu_value)i * self->val_step;

		// stvoryty n_cols
		lu_size x, y, cx, cy;
		N_Col col;
		N_Col temp_col;
		enum n_col_type type = NCT_PER;

		for (y = 0, cy = 0; y < self->n_cols_h; y++)
			for(x = 0, cx = 0; x < self->n_cols_w; x++)
			{
				col = NULL;

				if (y % 2 == 1)
				{
					temp_col = n_rec_n_cols_get(self, x, y - 1);
					switch(temp_col->type)
					{
						case NCT_COL:
							type = NCT_PER;
							break;
						case NCT_PER:
							type = NCT_PER_DIAG;
							break;
						default:
							lu_user_assert(false, "Impossible case, something is wrong");
					} 
				}
				else
					type = type == NCT_COL ? NCT_PER : NCT_COL;

				if (type == NCT_PER_DIAG)
					col = NULL;
				else
				{
					col = n_col_create(mem, self, x, y, type);
					lu_user_assert(col, "Cannot allocate n_col");
				}

				n_rec_n_cols_set(self, x, y, col);

				if (col && col->type == NCT_COL)
				{
					//lu_debug("\n(%d, %d)=>(%d, %d)", col->x, col->y, cx, cy);
					n_rec_colors_set(self, cx, cy, col);
					++cx;

					if (cx >= self->colors_w) ++cy;
				}
			}


		n_rec_debug_print(self);

		return self;
	}

