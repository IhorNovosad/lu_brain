/**
	Copyright Â© 2020 Oleh Ihorovych Novosad 
*/



	
	// static N_Rec n_rec_create(N_Mem n_mem, Lu_Rec rec)
	// {
	// 	lu_user_assert(n_mem, "N_Mem is NULL");
	// 	lu_user_assert(n_mem->brain, "n_mem->brain is NULL");
	// 	lu_user_assert(rec, "Rec is NULL");

	// 	Mem mem = n_mem->brain->mem_perm;

	// 	;

	// 	lu_user_assert(rec->width > 0, "Rec width is 0");
	// 	lu_user_assert(rec->height > 0, "Rec height is 0");

	// 	// N_Rec self 			= (N_Rec) mem_alloc(mem, sizeof(struct n_rec));
	// 	// lu_user_assert(self, "Cannot allocate N_Rec");

	// 	// lu_size w;
	// 	// lu_size h;

	// 	// if (rec->width == 1)
	// 	// 	w = 1;
	// 	// else 
	// 	// 	w = (lu_size) lu_value_round(((lu_value) rec->width) / 2.0);

	// 	// if (rec->height == 1)
	// 	// 	h = 1;
	// 	// else
	// 	// 	h = (lu_size) lu_value_round(((lu_value) rec->height) / 2.0);

	// 	// self->n_cols = (N_Col*) mem_alloc(
	// 	// 	mem, 
	// 	// 	sizeof(N_Col) * (rec->width + w) * (rec->height * h)
	// 	// );

	// 	// lu_user_assert(self->n_cols, "Cannot allocate N_Rec n_cols");

	// 	return self;
	// }


	static N_Rec n_rec_create(N_Mem n_mem, Lu_Rec rec)
	{
		lu_user_assert(n_mem, "N_Mem is NULL");
		lu_user_assert(n_mem->brain, "n_mem->brain is NULL");
		lu_user_assert(rec, "Rec is NULL");
		lu_user_assert(rec->max_value > rec->min_value, "Lu_Rec max_value should be greater than Lu_Rec min_value");
		lu_user_assert(rec->val_ssp > 0 && rec->val_ssp <= 0.5, "Lu_Rec val_ssp should be greater than 0 and less equal to 0.5");

		Mem mem = n_mem->brain->mem_perm;

		lu_user_assert(mem, "Mem is NULL");

		N_Rec self = (N_Rec) mem_alloc(mem, sizeof(struct n_rec));
		lu_user_assert(self, "Cannot allocate N_Rec");

		// // Initialize
		// self->mem			= mem;
		// self->w 			= rec->width;
		// self->h				= rec->height;
		// self->depth 		= rec->val_neu_size; // value depth in indexes
		// self->wh 			= self->w * self->h;
		// self->orig_min_val 	= rec->min_value;
		// self->orig_max_val 	= rec->max_value;
		// self->max_val 		= self->orig_max_val - self->orig_min_val;
		// self->val_step 		= self->max_val / (lu_value) self->depth;
		// self->val_ssp_i 	= (lu_size) lu_value_round(self->max_val * rec->val_ssp / self->val_step); // ssp in indexes

		// // my stvoruyemo indeksy/komirky/misce tut, sami neu_val budut stvoreni todi koly vony pershyy raz 
		// // budut zadiyani

		// lu_size neus_size 	= self->wh * self->depth * sizeof(lu_size*);
		// self->neus 			= (lu_size*) mem_alloc(mem, neus_size);
		// lu_user_assert(self->neus, "Cannot allocate neus");

		// memset(self->neus, ENT_NULL, neus_size);

	 // 	// Kroky preobchysleni
		// self->val_steps = (lu_value*) mem_alloc(mem, sizeof(lu_value) * self->depth);
		// lu_user_assert(self->val_steps, "Not enough memory for val_steps");
		
		// for (int i = 0; i < self->depth; i++) 
		// 	self->val_steps[i] = (lu_value)i * self->val_step;

		return self;
	}