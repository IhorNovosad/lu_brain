/**
	Copyright Â© 2020 Oleh Ihorovych Novosad 
*/

	static S_Rec s_rec_create(S_Mem s_mem, Lu_Rec rec)
	{
		lu_user_assert(s_mem, "S_Mem is NULL");
		lu_user_assert(s_mem->brain, "s_mem->brain is NULL");
		lu_user_assert(rec, "Rec is NULL");
		lu_user_assert(rec->v_max > rec->v_min, "Lu_Rec v_max should be greater than Lu_Rec v_min");
		
		lu_user_assert(rec->v_nsc >= 0 && rec->v_nsc <= rec->v_neu_size, "Lu_Rec v_nsc should be in [0, v_neu_size] range");
		lu_user_assert(rec->p_nsc >= 0 && rec->p_nsc <= rec->p_neu_size, "Lu_Rec p_nsc should be in [0, p_neu_size] range");
		lu_user_assert(rec->width > 0, "Lu_Rec width should be greater than 0");
		lu_user_assert(rec->height > 0, "Lu_Rec height should be greater than 0");

		Mem mem = s_mem->brain->mem_perm;

		lu_user_assert(mem, "Mem is NULL");

		S_Rec self = (S_Rec) mem_alloc(mem, sizeof(struct s_rec));
		lu_user_assert(self, "Cannot allocate S_Rec");

		self->mem				= s_mem;
		self->rec 				= rec;
		self->id 				= rec->id;


		self->cells_w 			= rec->width;
		self->cells_h			= rec->height; 

		///////////////////////////////////////
		// Confs

		s_col_conf_init(&self->v_conf, mem, rec->component_size, rec->v_min, rec->v_max, rec->v_neu_size, rec->v_nsc);
		s_col_conf_init(&self->p_conf, mem, rec->component_size, rec->v_min, rec->v_max, rec->p_neu_size, rec->p_nsc);


		///////////////////////////////////////
		// VP Layers
		self->vp_layers_size = self->cells_w > self->cells_h ? self->cells_w : self->cells_h;

		self->v_layers = (struct s_layer*) mem_alloc(mem, sizeof(struct s_layer) * self->vp_layers_size);
		lu_user_assert(self->v_layers, "Cannot allocate v layers"); 

		self->p_layers = (struct s_layer*) mem_alloc(mem, sizeof(struct s_layer) * self->vp_layers_size);
		lu_user_assert(self->v_layers, "Cannot allocate p layers");

		///////////////////////////////////////
		// A Layers

		self->a_layers_size = rec->blocks_size;

		self->av_layers = (struct s_layer*) mem_alloc(mem, sizeof(struct s_layer) * self->a_layers_size);
		lu_user_assert(self->av_layers, "Cannot allocate av layers"); 

		self->ap_layers = (struct s_layer*) mem_alloc(mem, sizeof(struct s_layer) * self->a_layers_size);
		lu_user_assert(self->ap_layers, "Cannot allocate ap layers");

		///////////////////////////////////////
		// Neus

		lu_size x;
		lu_size y;
		lu_size w;
		lu_size h;
		lu_size wh;

		w = self->cells_w;
		h = self->cells_h;
		wh = w * h;

		self->neus_size = 0;

		while (w > 0 && h > 0)
		{
			self->neus_size += w * h;
			if (w > 0) --w;
			if (h > 0) --h;
		}

		// dlia d i b 
		self->neus_size *= 2;

		// a_neus (n(n+1))/2 * 2 for d i b
		self->neus_size += rec->blocks_size * (rec->blocks_size + 1);
		self->neus_count = 0;

		self->neus = (struct s_neu*) mem_alloc(mem, sizeof(struct s_neu) * self->neus_size);
		lu_user_assert(self->neus, "Cannot allocate neus"); 

		///////////////////////////////////////
		// V links

		// cherez cells dlia p i c 
		self->v_links_size = self->neus_size - wh * 2;
		self->v_links_count = 0;

		self->v_links = (struct s_v_link*) mem_alloc(mem, sizeof(struct s_v_link) * self->v_links_size);
		lu_user_assert(self->v_links, "Cannot allocate v_links");

		///////////////////////////////////////
		// Cols

		self->cols_count = 0;
		self->cols_size = wh * self->v_conf.component_size + wh * self->p_conf.component_size;

		self->cols = (struct s_col*) mem_alloc(mem, sizeof(struct s_col) * self->cols_size);
		lu_user_assert(self->cols, "Cannot allocate cols");		

		///////////////////////////////////////
		// Init Layers And Neus

		w = self->cells_w;
		h = self->cells_h;
		lu_size layer_ix = 0;
		S_Neu v_neu;
		S_Neu p_neu;
		S_Layer v_layer;
		S_Layer p_layer;
		enum s_net_type type;

		while (w > 0 && h > 0)
		{
			if (w > 0) --w;
			if (h > 0) --h;

			v_layer = &self->v_layers[layer_ix];
			p_layer = &self->p_layers[layer_ix];

			s_layer_init(v_layer, self, mem, SLT_V, layer_ix, self->cells_w, self->cells_h);
			s_layer_init(p_layer, self, mem, SLT_P, layer_ix, self->cells_w, self->cells_h);

			if (layer_ix == 0) type = SNT_CELL;
			else type = SNT_NEU;

			for (y = 0; y < h; y++)
				for (x = 0; x < w; x++)
				{
					v_neu = s_rec_neu_init(self, mem, type, v_layer, x, y); 
					p_neu = s_rec_neu_init(self, mem, type, p_layer, x, y); 

					if (layer_ix > 0)
					{
						s_neu_b_layer_connect(v_neu, self->v_layers); 	
						s_neu_b_layer_connect(p_neu, self->p_layers);
					}

					s_neu_t_connect(v_neu, p_neu);
				}

			++layer_ix; 
		}

		return self;
	}

	static S_Neu s_rec_neu_init(S_Rec self, Mem mem, enum s_net_type type, S_Layer layer, lu_size x, lu_size y)
	{
		lu_user_assert(self->neus_count < self->neus_size, "Out of space for S_Neu");

		S_Neu neu = &self->neus[self->neus_count];
		s_neu_init(neu, type, layer, x, y);

		switch (type)
		{
			case SNT_CELL:
				s_rec_cell_init(self, mem, neu);
				break;
			case SNT_NEU:
				s_rec_full_neu_init(self, neu);
				break;
			case SNT_A_NEU:
				s_rec_a_neu_init(self, neu);
				break;
			default:
				lu_user_assert(false, "Unknown S_Neu type");
		}

		lu_user_assert(neu, "Cannot create S_Neu");

		s_layer_neu_set(layer, x, y, neu);

		++self->neus_count;

		return neu;
	}

	static S_V_Link s_rec_v_link_init(S_Rec self)
	{
		lu_user_assert(self->v_links_count < self->v_links_size, "Out of space for S_V_Link");

		S_V_Link link = &self->v_links[self->v_links_count];

		s_v_link_init(link);

		++self->v_links_count;

		return link;
	}

	static S_Col s_rec_col_init(S_Rec self, Mem mem,  S_Neu cell, S_Col_Conf conf)
	{
		lu_user_assert(self->cols_count < self->cols_size, "Out of space for S_Col");

		S_Col col = &self->cols[self->cols_count];

		s_col_init(col, mem, cell, conf);

		++self->cols_count;

		return col;
	}

	static S_Neu s_rec_cell_init(S_Rec self, Mem mem, S_Neu neu)
	{
		lu_user_assert(neu->type == SNT_CELL, "Wrong neu type");
		neu->d = s_rec_v_link_init(self);

		S_Layer layer = neu->layer;
		lu_user_assert(neu->layer, "S_Layer is NULL");

		S_Col_Conf conf = NULL;
		switch (layer->type)
		{
			case SLT_V:
				conf = &self->v_conf;
				break;
			case SLT_P:
				conf = &self->p_conf;
				break;
			default:
				lu_user_assert(false, "Wrong S_Layer type");
		}

		neu->cols = (S_Col) mem_alloc(mem, sizeof(struct s_col) * conf->component_size);
		lu_user_assert(neu->cols, "Cannot allocate cols");
		lu_size i;
		S_Col col;
		for(i = 0; i < conf->component_size; i++)
		{
			col = &neu->cols[i];

			s_col_init(col, mem, neu, conf);
		}

		neu->d = s_rec_v_link_init(self);

		return neu;
	}

	static S_Neu s_rec_full_neu_init(S_Rec self, S_Neu neu)
	{
		lu_user_assert(neu->type == SNT_NEU, "Wrong neu type");

		neu->b = s_rec_v_link_init(self);
		neu->d = s_rec_v_link_init(self);

		return neu;
	}

	static S_Neu s_rec_a_neu_init(S_Rec self, S_Neu neu)
	{

		lu_user_assert(neu->type == SNT_A_NEU, "Wrong neu type");

		neu->b = s_rec_v_link_init(self);
		neu->d = s_rec_v_link_init(self);

		return neu;
	}