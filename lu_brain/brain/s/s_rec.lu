/**
	Copyright Â© 2020 Oleh Ihorovych Novosad 
*/

	static S_Rec s_rec_create(S_Mem s_mem, Lu_Rec rec)
	{
		lu_user_assert(s_mem, "S_Mem is NULL");
		lu_user_assert(s_mem->brain, "s_mem->brain is NULL");
		lu_user_assert(rec, "Rec is NULL");
		lu_user_assert(rec->v_max > rec->v_min, "Lu_Rec v_max should be greater than Lu_Rec v_min");
		lu_user_assert(rec->p_nsc >= 0 && rec->p_nsc <= rec->p_neu_size, "Lu_Rec val_nsc should be greater than 0 and less equal to 0.5");
		lu_user_assert(rec->width > 0, "Lu_Rec width should be greater than 0");
		lu_user_assert(rec->height > 0, "Lu_Rec height should be greater than 0");

		Mem mem = s_mem->brain->mem_perm;

		lu_user_assert(mem, "Mem is NULL");

		S_Rec self = (S_Rec) mem_alloc(mem, sizeof(struct s_rec));
		lu_user_assert(self, "Cannot allocate S_Rec");

		self->mem				= s_mem;
		self->rec 				= rec;
		self->id 				= rec->id;
		self->component_size 	= rec->component_size;

		///////////////////////////////
		// v_conf

		self->v_conf.neu_size  	= rec->v_neu_size; // value depth in indexes
		self->v_conf.orig_min 	= rec->v_min;
		self->v_conf.orig_max 	= rec->v_max;
		self->v_conf.max 		= self->v_conf.orig_max - self->v_conf.orig_min;
		self->v_conf.step 		= self->v_conf.max / (lu_value) self->v_conf.neu_size;
		self->v_conf.nsc 		= 0; //(lu_size) lu_value_round(self->max_val * rec->val_nsc / self->v_conf.step); // nsc in indexes

	 	// Kroky preobchysleni
		self->v_conf.steps 		= (lu_value*) mem_alloc(mem, sizeof(lu_value) * self->v_conf.neu_size);
		lu_user_assert(self->v_conf.steps, "Cannot allocate c_val_steps");
		
		lu_size i;
		for (i = 0; i < self->v_conf.neu_size; i++)
			self->v_conf.steps[i] = (lu_value)i * self->v_conf.step;

		///////////////////////////////
		// v_cells

		self->cells_w 		= rec->width;
		self->cells_h		= rec->height;

		self->v_cells = (S_Cell*) mem_alloc(
			mem, 
			sizeof(S_Cell) * self->cells_w * self->cells_h 
		);
		lu_user_assert(self->v_cells, "Cannot allocate v_cells");

		self->p_cells = (S_Cell*) mem_alloc(
			mem, 
			sizeof(S_Cell) * self->cells_w * self->cells_h 
		);
		lu_user_assert(self->p_cells, "Cannot allocate p_cells");

		// stvoryty v_cells
		lu_size x, y;
		S_Cell cell;

		for (y = 0; y < self->cells_h; y++)
			for(x = 0; x < self->cells_w; x++)
			{
				cell = s_cell_create(mem, self, &self->v_conf, x, y);
				lu_user_assert(cell, "Cannot allocate v cell");
				s_rec_v_cell_set(self, x, y, cell);

				cell = s_cell_create(mem, self, &self->p_conf, x, y);
				lu_user_assert(cell, "Cannot allocate p cell");
				s_rec_p_cell_set(self, x, y, cell);
			}

		// calculate what we need 
		lu_size cell_count = rec->width * rec->height;
		lu_size v_col_count = self->component_size * cell_count;
		lu_size p_col_count = cell_count;

		lu_size neu_count = 0;

		x = rec->width;
		y = rec->height;
		
		while (x != 1 && y != 1)
		{
			if (x > 1) --x;
			if (y > 1) --y;

			
		} 

		return self;
	}

