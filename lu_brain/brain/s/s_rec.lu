/**
	Copyright Â© 2020 Oleh Ihorovych Novosad 
*/

	static void s_rec_debug_print(S_Rec self)
	{
		lu_debug("\n---------------------");
		lu_debug("\nn_cols(%d, %d): ", self->s_cells_w, self->s_cells_h);
		lu_size x, y;
		S_Cell cell;
		for(y = 0; y < self->s_cells_h; y++)
		{
			lu_debug("\n");
			for(x = 0; x < self->s_cells_w; x++)
			{
				cell = s_rec_s_cell_get(self, x, y);

				if (cell == NULL)
					lu_debug(" ");
				else
				{
					switch(cell->type)
					{
						case SCT_COL:
							lu_debug("c", cell->data_x, cell->data_y);
							break;
						case SCT_PER_HOR:
							lu_debug("h");
							break;
						case SCT_PER_VER:
							lu_debug("v");
							break;
						case SCT_PER_DIAG:
							lu_debug("x");
							break;
						default:
							lu_debug("ERROR");
					}
				} 
			}
		}

		lu_debug("\n");
	}

	static S_Rec s_rec_create(S_Mem s_mem, Lu_Rec rec)
	{
		lu_user_assert(s_mem, "S_Mem is NULL");
		lu_user_assert(s_mem->brain, "s_mem->brain is NULL");
		lu_user_assert(rec, "Rec is NULL");
		lu_user_assert(rec->v_max > rec->v_min, "Lu_Rec v_max should be greater than Lu_Rec v_min");
		lu_user_assert(rec->p_nsc >= 0 && rec->p_nsc <= rec->p_neu_size, "Lu_Rec val_nsc should be greater than 0 and less equal to 0.5");

		Mem mem = s_mem->brain->mem_perm;

		lu_user_assert(mem, "Mem is NULL");

		S_Rec self = (S_Rec) mem_alloc(mem, sizeof(struct s_rec));
		lu_user_assert(self, "Cannot allocate S_Rec");

		self->s_mem				= s_mem;
		self->rec 				= rec;
		self->id 				= rec->id;
		self->component_size 	= rec->component_size;

		///////////////////////////////
		// v_conf

		self->v_conf.neu_size  	= rec->v_neu_size; // value depth in indexes
		self->v_conf.orig_min 	= rec->v_min;
		self->v_conf.orig_max 	= rec->v_max;
		self->v_conf.max 		= self->v_conf.orig_max - self->v_conf.orig_min;
		self->v_conf.step 		= self->v_conf.max / (lu_value) self->v_conf.neu_size;
		self->v_conf.nsc 		= 0; //(lu_size) lu_value_round(self->max_val * rec->val_nsc / self->v_conf.step); // nsc in indexes

	 	// Kroky preobchysleni
		self->v_conf.steps 		= (lu_value*) mem_alloc(mem, sizeof(lu_value) * self->v_conf.neu_size);
		lu_user_assert(self->v_conf.steps, "Cannot allocate c_val_steps");
		
		lu_size i;
		for (i = 0; i < self->v_conf.neu_size; i++)
			self->v_conf.steps[i] = (lu_value)i * self->v_conf.step;

		///////////////////////////////
		// s_cells

		// rec->width = 10;
		// rec->height = 10;

		if (rec->width == 1)
			self->pers_w = 0;
		else 
			self->pers_w = rec->width - 1;

		if (rec->height == 1)
			self->pers_h = 0;
		else
			self->pers_h = rec->height - 1;

		//lu_debug("\npers_w = %d, pers_h = %d \n", self->pers_w, self->pers_h);

		self->s_cells_w 		= rec->width + self->pers_w;
		self->s_cells_h			= rec->height + self->pers_h;

		self->s_cells = (S_Cell*) mem_alloc(
			mem, 
			sizeof(S_Cell) * self->s_cells_w * self->s_cells_h 
		);

		lu_user_assert(self->s_cells, "Cannot allocate s_cells");

		// stvoryty s_cells
		lu_size x, y, cx, cy;
		S_Cell cell;
		S_Cell temp_cell;
		enum s_cell_type type = SCT_PER_HOR;

		for (y = 0, cy = 0; y < self->s_cells_h; y++)
			for(x = 0, cx = 0; x < self->s_cells_w; x++)
			{
				cell = NULL;

				if (y % 2 == 1)
				{
					temp_cell = s_rec_s_cell_get(self, x, y - 1);

					if (temp_cell)
					{
						switch(temp_cell->type)
						{
							case SCT_COL:
								type = SCT_PER_VER;
								break;
							case SCT_PER_HOR:
								type = SCT_PER_DIAG;
								break;
							default:
								lu_user_assert(false, "Impossible case, something is wrong");
						} 
					}
				}
				else
					type = type == SCT_COL ? SCT_PER_HOR : SCT_COL;

				if (type == SCT_PER_DIAG)
					cell = NULL;
				else //if (type != SCT_COL)
				{
					cell = s_cell_create(mem, self, cx, cy, x, y, type);
					lu_user_assert(cell, "Cannot allocate s_col");
					s_rec_s_cell_set(self, x, y, cell);
				}

				if (type == SCT_COL)
				{
					++cx;

					if (cx >= rec->width) ++cy;
				}

				
			}


		s_rec_debug_print(self);

		return self;
	}

