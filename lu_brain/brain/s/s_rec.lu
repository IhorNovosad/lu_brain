/**
	Copyright Â© 2020 Oleh Ihorovych Novosad 
*/

	static S_Rec s_rec_create(S_Mem s_mem, Lu_Rec rec)
	{
		lu_user_assert(s_mem, "S_Mem is NULL");
		lu_user_assert(s_mem->brain, "s_mem->brain is NULL");
		lu_user_assert(rec, "Rec is NULL");
		lu_user_assert(rec->v_max > rec->v_min, "Lu_Rec v_max should be greater than Lu_Rec v_min");
		
		lu_user_assert(rec->v_nsc >= 0 && rec->v_nsc <= rec->v_neu_size, "Lu_Rec v_nsc should be in [0, v_neu_size] range");
		lu_user_assert(rec->p_nsc >= 0 && rec->p_nsc <= rec->p_neu_size, "Lu_Rec p_nsc should be in [0, p_neu_size] range");
		lu_user_assert(rec->width > 0, "Lu_Rec width should be greater than 0");
		lu_user_assert(rec->height > 0, "Lu_Rec height should be greater than 0");

		Mem mem = s_mem->brain->app_mem;

		lu_user_assert(mem, "Mem is NULL");

		S_Rec self = (S_Rec) mem_alloc(mem, sizeof(struct s_rec));
		lu_user_assert(self, "Cannot allocate S_Rec");

		self->mem				= s_mem;
		self->rec 				= rec;
		self->id 				= rec->id;

		self->cells_w 			= rec->width;
		self->cells_h			= rec->height; 
		self->cells_d 			= rec->depth;

		///////////////////////////////////////
		// Confs

		s_layer_conf_init(&self->v_conf, mem, rec->v_min, rec->v_max, rec->v_neu_size, rec->v_nsc);
		s_layer_conf_init(&self->p_conf, mem, rec->v_min, rec->v_max, rec->p_neu_size, rec->p_nsc);

		///////////////////////////////////////
		// VP Layers

		self->vp_layers_size = (self->cells_w > self->cells_h ? self->cells_w : self->cells_h) + 2; 	// odyn dlia component, odyn dlia val

		self->v_layers = (struct s_layer*) mem_alloc(mem, sizeof(struct s_layer) * self->vp_layers_size);
		lu_user_assert(self->v_layers, "Cannot allocate v layers"); 

		self->p_layers = (struct s_layer*) mem_alloc(mem, sizeof(struct s_layer) * self->vp_layers_size);
		lu_user_assert(self->v_layers, "Cannot allocate p layers");

		///////////////////////////////////////
		// A Layers

		self->blocks_size		= rec->blocks_size;
		self->a_layers_size 	= self->blocks_size;	// a_layers_size = blocks_size, but potentially they could be different

		self->av_layers = (struct s_layer*) mem_alloc(mem, sizeof(struct s_layer) * self->a_layers_size);
		lu_user_assert(self->av_layers, "Cannot allocate av layers"); 

		self->ap_layers = (struct s_layer*) mem_alloc(mem, sizeof(struct s_layer) * self->a_layers_size);
		lu_user_assert(self->ap_layers, "Cannot allocate ap layers");

		///////////////////////////////////////
		// Neus

		lu_size x;
		lu_size y;
		lu_size z;
		lu_size w 	= self->cells_w;
		lu_size h 	= self->cells_h;
		lu_size d	= self->cells_d;
		lu_size wh 	= w * h;

		self->neus_size = 0;

		while (w > 0 && h > 0)
		{
			self->neus_size += w * h * d;
			if (w > 0) --w;
			if (h > 0) --h;
			if (d > 1) d = 1; 
		}

		// dlia d i b 
		self->neus_size *= 2;

		// a_neus (n(n+1))/2 * 2 for d i b
		self->neus_size += self->blocks_size * (self->blocks_size + 1);
		self->neus_count = 0;
		self->neus = (struct s_neu*) mem_alloc(mem, sizeof(struct s_neu) * self->neus_size);
		lu_user_assert(self->neus, "Cannot allocate neus"); 

		///////////////////////////////////////
		// Init Layers And Neus

		w = self->cells_w;
		h = self->cells_h;
		d = self->cells_d;
		lu_size layer_ix = 0;
		S_Neu v_neu;
		S_Neu p_neu;
		S_Layer v_layer;
		S_Layer p_layer;
		S_Layer b_v_layer = NULL;
		S_Layer b_p_layer = NULL;

		enum s_neu_type type;

		v_layer = &self->v_layers[layer_ix];
		p_layer = &self->p_layers[layer_ix];

		s_rec_val_layers_init(self, v_layer, p_layer, mem);

		b_v_layer = v_layer;
		b_p_layer = p_layer;

		++layer_ix;

		v_layer = &self->v_layers[layer_ix];
		p_layer = &self->p_layers[layer_ix];

		s_rec_comp_layers_init(self, v_layer, p_layer, b_v_layer, b_p_layer, mem);

		b_v_layer = v_layer;
		b_p_layer = p_layer;

		++layer_ix;

		v_layer = &self->v_layers[layer_ix];
		p_layer = &self->p_layers[layer_ix];

		s_rec_cell_layers_init(self, v_layer, p_layer, b_v_layer, b_p_layer, mem);

		--w;
		--h;

		while (w > 0 && h > 0)
		{
			lu_user_assert(layer_ix < self->vp_layers_size, "Wrong layer index");

			b_v_layer = v_layer;
			b_p_layer = p_layer;

			++layer_ix; 

			v_layer = &self->v_layers[layer_ix];
			p_layer = &self->p_layers[layer_ix];

			s_rec_neu_layers_init(self, v_layer, p_layer, b_v_layer, b_p_layer, mem, w, h, layer_ix);

			if (w > 0) --w;
			if (h > 0) --h;
		}

		lu_user_assert(v_layer->w == 1 && v_layer->h == 1, "Something wrong with v_layer");
		lu_user_assert(p_layer->w == 1 && p_layer->h == 1, "Something wrong with p_layer");

		///////////////////////////////////////
		// Init A Layers 
		S_Layer av_layer;
		S_Layer ap_layer;
		S_Layer b_av_layer = NULL;
		S_Layer b_ap_layer = NULL;
		layer_ix = 0;
		w = self->blocks_size;
		y = 1;
		d = 1;

		while(w > 0)
		{
			lu_user_assert(layer_ix < self->a_layers_size, "Wrong layer index");

			av_layer = &self->av_layers[layer_ix];
			ap_layer = &self->ap_layers[layer_ix];

			if (layer_ix > 0)
			{
				b_av_layer = &self->av_layers[layer_ix - 1];
				b_ap_layer = &self->ap_layers[layer_ix - 1];
			}

			s_layer_init(av_layer, self, mem, SLT_AV, layer_ix, w, y, d);
			lu_user_assert(av_layer, "Cannot init av_layer");
			s_layer_init(ap_layer, self, mem, SLT_AP, layer_ix, w, y, d);
			lu_user_assert(ap_layer, "Cannot init ap_layer");

			for (x = 0; x < w; x++)
			{
				v_neu = s_rec_neu_init(self, mem, SNT_A_NEU, av_layer, x, y - 1, d - 1); 
				lu_user_assert(v_neu, "Cannot init v_neu");
				p_neu = s_rec_neu_init(self, mem, SNT_A_NEU, ap_layer, x, y - 1, d - 1); 
				lu_user_assert(p_neu, "Cannot init p_neu");

				if (layer_ix > 0)
				{
					s_a_neu_b_layer_connect(v_neu, b_av_layer); 	
					s_a_neu_b_layer_connect(p_neu, b_ap_layer);
				}

				s_neu_t_connect(v_neu, p_neu);
			}

			++layer_ix;
			--w;
		}

		// lu_debug("\nneus_count = %d, neus_size = %d", self->neus_count, self->neus_size);

		lu_user_assert(self->neus_count == self->neus_size, "Something wrong with neus_count");

		return self;
	}
