/**
	Copyright Â© 2020 Oleh Ihorovych Novosad 
*/

	static S_Rec s_rec_create(S_Mem s_mem, Lu_Rec rec)
	{
		lu_user_assert(s_mem, "S_Mem is NULL");
		lu_user_assert(s_mem->brain, "s_mem->brain is NULL");
		lu_user_assert(rec, "Rec is NULL");
		lu_user_assert(rec->v_max > rec->v_min, "Lu_Rec v_max should be greater than Lu_Rec v_min");
		
		lu_user_assert(rec->v_nsc >= 0 && rec->v_nsc <= rec->v_neu_size, "Lu_Rec v_nsc should be in [0, v_neu_size] range");
		lu_user_assert(rec->p_nsc >= 0 && rec->p_nsc <= rec->p_neu_size, "Lu_Rec p_nsc should be in [0, p_neu_size] range");
		lu_user_assert(rec->width > 0, "Lu_Rec width should be greater than 0");
		lu_user_assert(rec->height > 0, "Lu_Rec height should be greater than 0");

		Mem mem = s_mem->brain->app_mem;

		lu_user_assert(mem, "Mem is NULL");

		S_Rec self = (S_Rec) mem_alloc(mem, sizeof(struct s_rec));
		lu_user_assert(self, "Cannot allocate S_Rec");

		self->mem				= s_mem;
		self->rec 				= rec;
		self->id 				= rec->id;

		self->cells_w 			= rec->width;
		self->cells_h			= rec->height; 
		self->cells_d 			= rec->depth;

		///////////////////////////////////////
		// Confs

		s_layer_conf_init(&self->v_conf, mem, rec->v_min, rec->v_max, rec->v_neu_size, rec->v_nsc);
		s_layer_conf_init(&self->p_conf, mem, rec->v_min, rec->v_max, rec->p_neu_size, rec->p_nsc);

		///////////////////////////////////////
		// Allocate VP Layers

		self->vp_layers_size = (self->cells_w > self->cells_h ? self->cells_w : self->cells_h);
		
		if (self->cells_d > 1)
			++self->vp_layers_size; // + odyn dlia component 
																				

		self->v_layers = (struct s_layer*) mem_alloc(mem, sizeof(struct s_layer) * self->vp_layers_size);
		lu_user_assert(self->v_layers, "Cannot allocate v layers"); 

		self->p_layers = (struct s_layer*) mem_alloc(mem, sizeof(struct s_layer) * self->vp_layers_size);
		lu_user_assert(self->v_layers, "Cannot allocate p layers");

		///////////////////////////////////////
		// Allocate Tria Layers

		self->blocks_size		= rec->blocks_size;
		self->tria_layers_size 	= self->blocks_size;	// tria_layers_size = blocks_size, but potentially they could be different

		self->tria_v_layers = (struct s_layer*) mem_alloc(mem, sizeof(struct s_layer) * self->tria_layers_size);
		lu_user_assert(self->tria_v_layers, "Cannot allocate av layers"); 

		self->tria_p_layers = (struct s_layer*) mem_alloc(mem, sizeof(struct s_layer) * self->tria_layers_size);
		lu_user_assert(self->tria_p_layers, "Cannot allocate ap layers");

		///////////////////////////////////////
		// All layers init

		s_rec_layers_init(self, mem);

		///////////////////////////////////////
		// Allocate neus

		self->neus = (struct s_neu*) mem_alloc(mem, sizeof(struct s_neu) * self->neus_size);
		lu_user_assert(self->neus, "Cannot allocate neus"); 

		///////////////////////////////////////
		// Init neus

		s_rec_components_init(self, mem);
		s_rec_cells_init(self, mem);
		s_rec_pyras_init(self, mem);
		s_rec_trias_init(self, mem);

		//lu_debug("\nneus_count = %d, neus_size = %d, rw=%d, rh=%d, rd=%d", self->neus_count, self->neus_size, self->cells_w, self->cells_h, self->cells_d);

		lu_user_assert(self->neus_count == self->neus_size, "Something wrong with neus_count");

		return self;
	}

	/*
	** Allocate space for S_Neu
	*/
	static S_Neu s_rec_neu_alloc(S_Rec self, Mem mem, enum s_neu_type type, S_Layer layer, lu_size x, lu_size y, lu_size z)
	{
		lu_user_assert(self->neus_count < self->neus_size, "Out of space for S_Neu");

		S_Neu neu = &self->neus[self->neus_count];
		neu = s_neu_init(neu, type, layer, x, y, z);
		lu_user_assert(neu, "Cannot init S_Neu");

		s_layer_neu_set(layer, x, y, z, neu);

		// lock 
		neu->l_ix = self->neus_count;
		++layer->neus_count;
		++self->neus_count;

		return neu;
	}  


	static void s_rec_print_info(S_Rec self)
	{
		lu_user_assert_void(self, "S_Rec is NULL");

		lu_debug("\n\n 	-- S_Rec #%lu info: ", self->id);
 		lu_debug("\n 	 	%-17s %lu", "cells_w:", self->cells_w);
 		lu_debug("\n 	 	%-17s %lu", "cells_h:", self->cells_h);
 		lu_debug("\n 	 	%-17s %lu", "cells_d:", self->cells_d);
 		lu_debug("\n 	 	");
 		lu_debug("\n 	 	%-17s %lu", "neus_size:", self->neus_size);
 		lu_debug("\n 	 	%-17s %lu", "neus_count:", self->neus_count);
 		lu_debug("\n 	 	%-17s %lu", "vp_layers_size:", self->vp_layers_size);
 		lu_debug("\n 	 	%-17s %lu", "blocks_size:", self->blocks_size);
 		lu_debug("\n 	 	%-17s %lu", "tria_layers_size:", self->tria_layers_size);
 		lu_debug("\n 	 	");


 		lu_size i;
 		S_Layer layer;
 		struct s_layer* layers;

 		// vp_layers
 		if (rand() % 2 == 0) 
 		{
			layers = self->v_layers;
 		}
 		else
 		{
			layers = self->p_layers;
 		}

 		for(i = 0; i < self->vp_layers_size; i++)
 		{
 			layer = &layers[i];

 			s_layer_print_info(layer);
 		}

 		// tria_layers
 		lu_debug("\n");
 		if (rand() % 2 == 0) 
 		{
			layers = self->tria_v_layers;
 		}
 		else
 		{
			layers = self->tria_p_layers;
 		}

 		for(i = 0; i < self->tria_layers_size; i++)
 		{
 			layer = &layers[i];

 			s_layer_print_info(layer);
 		}

	}