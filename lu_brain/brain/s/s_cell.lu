/**
	Copyright Â© 2020 Oleh Ihorovych Novosad 
*/

///////////////////////////////////////////////////////////////////////////////
// Create and destroy

	static S_Col s_col_create(
		Mem mem, 
		S_Rec s_rec, 
		lu_size data_x, 
		lu_size data_y,
		lu_size x, 
		lu_size y, 
		enum n_col_type type
	)
	{
		lu_user_assert(s_rec, "S_Rec is NULL");
		lu_user_assert(type > NCT_FIRST && type < NCT_LAST, "Unknown enum n_col_type");

		S_Col self = (S_Col) mem_alloc(mem, sizeof(struct s_cell));

		self->s_rec 	= s_rec;

		self->data_x 	= data_x;
		self->data_y 	= data_y;
		self->x 		= x;
		self->y 		= y;
		self->type 		= type;

		self->n_vals 	= (lu_p_size) mem_alloc(mem, sizeof(lu_size) * s_rec->val_neu_size);

		return self;
	}

///////////////////////////////////////////////////////////////////////////////
// Calculations

	static lu_value s_col_norm(S_Col self, lu_value request)
	{
		lu_value val = request - self->s_rec->orig_min_val;
		if (val < 0) val = 0;
		if (val > self->s_rec->max_val) val = self->s_rec->max_val;

		return val;
	}

	static lu_size n_col_indx(S_Col self, lu_value val)
	{
		return (lu_size) lu_value_round(val / self->s_rec->val_step);
	}

	static struct lu_size_range s_col_indx_range(S_Col self, lu_value val)
	{
		lu_size orig_i = n_col_indx(self, val);

		long begin, end;

		begin = orig_i - self->s_rec->val_ssp_i;
		if (begin < 0) begin = 0;

		end = orig_i + self->s_rec->val_ssp_i;
		if (end > (self->s_rec->val_neu_size - 1)) end = self->s_rec->val_neu_size - 1; 

		struct lu_size_range r;
		r.begin = (lu_size) begin;
		r.end = (lu_size) end;
		return r;
	}

	static lu_value s_col_calc_sig(S_Col self, lu_size val_step_i, lu_value val)
	{ 
		return 1.0 - lu_value_abs(self->s_rec->val_steps[val_step_i] - val) / self->s_rec->max_val;
	}

	static lu_value s_col_step_norm_dist(S_Col self)
	{
		return 1.0 / self->s_rec->val_neu_size;
	}

	static lu_size n_col_c_neu_get(S_Col self, lu_size indx)
	{
		lu_size c_neu_ent = self->n_vals[indx];
		if (c_neu_ent == ENT_NULL)
		{
			S_Rec s_rec = self->s_rec;
			lu_user_assert_ent(s_rec, "S_Rec is NULL");
			S_Mem s_mem = s_rec->s_mem;
			lu_user_assert_ent(s_mem, "S_Mem is NULL");

			c_neu_ent = s_mem_c_neu_create(s_mem, self);
			self->n_vals[indx] = c_neu_ent;
		}

		return c_neu_ent;
	}

	static lu_size s_col_neu_ent_get(S_Col self, lu_value input_val)
	{
		lu_value norm_val 	= s_col_norm(self, input_val);
		lu_size indx 		= n_col_indx(self, norm_val);

		return n_col_c_neu_get(self, indx);
	}