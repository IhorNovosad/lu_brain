/**
	Copyright Â© 2020 Oleh Ihorovych Novosad 
*/

///////////////////////////////////////////////////////////////////////////////
// Save_Wave_Create_Opts

	static void save_wave_create_opts_init(Save_Wave_Create_Opts self)
	{
		self->max_story_size_in_blocks = 16;
	}

///////////////////////////////////////////////////////////////////////////////
// Save_Wave

	static void save_wave_init(Save_Wave self, Story story, Save_Opts opts)
	{
		if (opts)
			self->save_opts = *opts;

		self->story = story;
	} 

	static Save_Wave save_wave_create(Gate gate, Save_Wave_Create_Opts opts)
	{
		lu_user_assert(opts->max_story_size_in_blocks > 0, "Option max_story_size_in_blocks should be greater than 0");
		lu_user_assert(gate, "Gate is NULL");

		Brain brain = gate->brain;

		lu_user_assert(brain, "Brain is NULL");

		Mem mem = brain->mem_perm;

		lu_user_assert(mem, "Mem is NULL");

		Save_Wave self 		= (Save_Wave) mem_alloc(mem, sizeof(struct save_wave));

		wave_init(&self->super, gate);

		lu_user_assert(self, "Unable to allocate Save_Wave");

		lu_user_assert(arr_count(brain->recs) > 0, "Brain has no recs");

		self->prev_data = (Arr*) mem_alloc(mem, sizeof(Arr*) * arr_count(brain->recs));
		Rec rec;
		for (lu_size rec_i = 0; rec_i < arr_count(brain->recs); rec_i++)
		{
			rec 	= lu_brain_rec_get(brain, rec_i);

			lu_user_assert(rec->depth, "Rec channel size is 0");

			self->prev_data[rec_i] = arr_create(mem, rec->depth);
		}
	
		return self;
	}

	static void save_wave_reset(Save_Wave self)
	{
		lu_user_assert_void(self, "Wave is NULL");
		lu_user_assert_void(self->super.gate, "Gate is NULL");

		Brain brain = self->super.gate->brain;

		lu_user_assert_void(brain, "Brain is NULL");

		lu_user_assert_void(arr_count(brain->recs) > 0, "Brain has no recs");

		// Reset prev_data
		Arr channels;
		lu_size rec_i, chan_i;
		Rec rec;
		for (rec_i = 0; rec_i < arr_count(brain->recs); rec_i++)
		{
			rec 	= lu_brain_rec_get(brain, rec_i);

			lu_user_assert_void(rec->depth, "Rec channel size is 0");

			channels = self->prev_data[rec_i];
			for (chan_i = 0; chan_i < arr_count(channels); chan_i++)
				arr_set(channels, chan_i, NULL);
		}
	}

	static void save_wave_process(Save_Wave self)
	{
		// vse connetytsia po chasu
		// i sytuaciyu v odnomu rec 
		// i sytuaciyu mizh rec
		// i osoblyvo sytuaciyi v odnomu bloci

		// znachenia dlia neurons isnuyut tilky dlia potochnoyi wave
		// yaki my attachymo do neus yak componentu ES

		// if (self == NULL) {
		// 	lu_user_debug("self should not be NULL");
		// 	return;
		// }

		// Story story = self->story;

		// if (story == NULL) {
		// 	lu_user_debug("story should not be NULL");
		// 	return;
		// }

		// if (story->data_y < 1) {
		// 	lu_user_debug("story without blocks");
		// 	return;
		// }

		// arr_each_with_index_1p(story->blocks, save_wave_each_block_save, self);
	}