/**
	Copyright Â© 2020 Oleh Ihorovych Novosad 
*/

///////////////////////////////////////////////////////////////////////////////
// Save_Wave_Create_Opts

	static void save_wave_create_opts_init(Save_Wave_Create_Opts self)
	{
		self->max_story_size_in_blocks = 16;
	}

///////////////////////////////////////////////////////////////////////////////
// Save_Wave

	static void save_wave_init(Save_Wave self, Lu_Story story, Lu_Save_Opts opts)
	{
		if (opts)
			self->save_opts = *opts;

		self->super.story = story;
	} 

	static void save_wave_reset(Save_Wave self)
	{
		lu_user_assert_void(self, "Lu_Wave is NULL");
		lu_user_assert_void(self->super.gate, "Gate is NULL");

		Lu_Brain brain = self->super.gate->brain;

		lu_user_assert_void(brain, "Lu_Brain is NULL");
		lu_user_assert_void(arr_count(brain->recs) > 0, "Lu_Brain has no recs");

		for (lu_size rec_i = 0; rec_i < arr_count(brain->recs); rec_i++)
			self->fill_data[rec_i] = NULL;
	}

	static Save_Wave save_wave_create(Gate gate, Save_Wave_Create_Opts opts)
	{
		lu_user_assert(opts->max_story_size_in_blocks > 0, "Option max_story_size_in_blocks should be greater than 0");
		lu_user_assert(gate, "Gate is NULL");

		Lu_Brain brain = gate->brain;

		lu_user_assert(brain, "Lu_Brain is NULL");

		Mem mem = brain->mem_perm;

		lu_user_assert(mem, "Mem is NULL");

		Save_Wave self 		= (Save_Wave) mem_alloc(mem, sizeof(struct save_wave));

		wave_init(&self->super, gate);

		lu_user_assert(self, "Unable to allocate Save_Wave");

		lu_user_assert(arr_count(brain->recs) > 0, "Lu_Brain has no recs");

		self->fill_data = (lu_p_value*) mem_alloc(mem, sizeof(lu_p_value*) * arr_count(brain->recs));

		save_wave_reset(self);

		return self;
	}

	static void save_wave_data_send(Save_Wave self, N_Rec n_rec, lu_p_value data, lu_size block_i)
	{
		lu_user_assert_void(self, "Lu_Wave is NULL");
		lu_user_assert_void(n_rec, "N_Rec is NULL");
		lu_user_assert_void(data, "Data is NULL");

		// lu_size x, y, z;
		// lu_value value;
		// lu_value values[n_rec->component_size];
		// N_Col col;

		// for(y = 0; y < n_rec->colors_h; y++)
		// 	for(x = 0; x < n_rec->colors_w; x++)
		// 	{
		// 		col = n_rec_colors_get(n_rec, x, y);

		// 		lu_user_assert_void(col, "N_Col is NULL");

		// 		// zibraty koliory
		// 		for(z = 0; z < self->component_size; z++)
		// 		{
		// 			value = lu_data_get(data, self->colors_w, self->colors_h, self->component_size, x, y, z);
		// 			values[z] = value;
		// 		} 

		// 		n_col_data_send(col, wave, values);
		// 	}
	}

	static void save_wave_rec_progress(Save_Wave wave, N_Rec n_rec, lu_size block_i)
	{

	}

	static void save_wave_block_progress(Save_Wave wave, lu_size block_i)
	{

	}