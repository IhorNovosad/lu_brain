/**
	Copyright Â© 2020 Oleh Ihorovych Novosad 
*/

///////////////////////////////////////////////////////////////////////////////
// Save_Wave_Create_Opts

	static void save_wave_create_opts_init(Save_Wave_Create_Opts self)
	{
		self->block_neus_size = 256;
	}

///////////////////////////////////////////////////////////////////////////////
// Save_Wave

	static void save_wave_init(Save_Wave self, Story story, Save_Opts opts)
	{
		if (opts)
			self->save_opts = *opts;

		self->story = story;
	}

	static Save_Wave save_wave_create(Mem mem, Save_Wave_Create_Opts opts)
	{
		lu_assert(opts->block_neus_size > 0);

		Save_Wave self 		= (Save_Wave) mem_alloc(mem, sizeof(struct save_wave));

		self->block_neus 	= arr_create(mem, opts->block_neus_size);

		return self;
	}


	static void save_wave_each_block_save(lu_p_void item, lu_p_void p1)
	{
		Block block 		= (Block) item;
		Save_Wave wave 		= (Save_Wave) p1;
		arr_append(wave->block_neus, block_save(block, wave));
	}

	static void save_wave_process(Save_Wave self)
	{
		// vse connetytsia po chasu
		// i sytuaciyu v odnomu rec i 
		// i sytuaciyu mizh rec
		// i osoblyvo sytuaciyi v odnomu bloci

		// znachenia dlia neurons isnuyut tilky dlia potochnoyi wave

		if (self == NULL) {
			lu_user_throw("self should not be NULL");
			return;
		}

		Story story = self->story;

		if (story == NULL) {
			lu_user_throw("story should not be NULL");
			return;
		}

		if (story->blocks == NULL || arr_count(story->blocks) < 1) {
			lu_user_throw("story without blocks");
			return;
		}

		if (arr_count(story->blocks) > arr_count(self->block_neus))
		{
			lu_user_throw("not enough block neus for story size");
			return;
		}


		// simplified atm
		// multithreading required 
		//arr_each_1p(story->blocks, save_wave_each_block_save, self);
	}