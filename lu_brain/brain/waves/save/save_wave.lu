/**
	Copyright Â© 2020 Oleh Ihorovych Novosad 
*/

///////////////////////////////////////////////////////////////////////////////
// Save_Wave_Create_Opts

	static void save_wave_create_opts_init(Save_Wave_Create_Opts self)
	{
		self->max_story_size_in_blocks = 16;
	}

///////////////////////////////////////////////////////////////////////////////
// Save_Wave

	static void save_wave_init(Save_Wave self, Story story, Save_Opts opts)
	{
		if (opts)
			self->save_opts = *opts;

		self->story = story;
	}

	static Save_Wave save_wave_create(Gate gate, Save_Wave_Create_Opts opts)
	{
		lu_assert(opts->max_story_size_in_blocks > 0);
		lu_assert(gate && gate->brain && gate->brain->mem_perm);

		Brain brain 	= gate->brain;
		Mem mem 		= brain->mem_perm;

		Save_Wave self 		= (Save_Wave) mem_alloc(mem, sizeof(struct save_wave));

		lu_user_assert(self, "Unable to allocate Save_Wave");

		self->recs_data = arr_create(mem, arr_count(brain->recs));

		lu_user_assert(self->recs_data, "Unable to allocate memory for recs_data");

		lu_size i, j;
		Rec rec;
		Arr channels;
		lu_p_value block;
		for(i = 0; i < arr_count(self->recs_data); i++)
		{
			rec = (Rec) arr_get(brain->recs, i);

			channels = arr_create(mem, rec->channel_size);
			lu_user_assert(channels, "Unable to allocate memory for channels");

			for(j = 0; j < arr_count(channels); j++)
			{
				lu_p_value block = (lu_p_value) mem_alloc(
					mem, 
					// here max_story_size_in_blocks + 1 because block[0] item is used to save 
					// info z poperednioyi istoriyi. Potochna istoriya pochynayetsia z block[1]
					sizeof(lu_value) * rec->width * rec->height * opts->max_story_size_in_blocks + 1
				);

				lu_user_assert(block, "Unable to allocate memory for channel");

				arr_set(channels, j, block);
			}

			arr_set(self->recs_data, i, channels);
		}
	
		return self;
	}

	static void save_wave_process(Save_Wave self)
	{
		// vse connetytsia po chasu
		// i sytuaciyu v odnomu rec 
		// i sytuaciyu mizh rec
		// i osoblyvo sytuaciyi v odnomu bloci

		// znachenia dlia neurons isnuyut tilky dlia potochnoyi wave
		// yaki my attachymo do neus yak componentu ES

		// if (self == NULL) {
		// 	lu_user_debug("self should not be NULL");
		// 	return;
		// }

		// Story story = self->story;

		// if (story == NULL) {
		// 	lu_user_debug("story should not be NULL");
		// 	return;
		// }

		// if (story->data_y < 1) {
		// 	lu_user_debug("story without blocks");
		// 	return;
		// }

		// arr_each_with_index_1p(story->blocks, save_wave_each_block_save, self);
	}