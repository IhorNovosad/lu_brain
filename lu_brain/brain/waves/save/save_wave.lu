/**
	Copyright Â© 2020 Oleh Ihorovych Novosad 
*/

///////////////////////////////////////////////////////////////////////////////
// Save_Wave_Create_Opts

	static void save_wave_create_opts_init(Save_Wave_Create_Opts self)
	{
		self->max_story_size_in_blocks = 16;
	}

///////////////////////////////////////////////////////////////////////////////
// Save_Wave

	static void save_wave_init(Save_Wave self, Lu_Story story, Lu_Save_Opts opts)
	{
		if (opts)
			self->save_opts = *opts;

		self->super.story = story;
	} 

	static void save_wave_reset(Save_Wave self)
	{
		lu_user_assert_void(self, "Lu_Wave is NULL");
		lu_user_assert_void(self->super.gate, "Gate is NULL");

		Lu_Brain brain = self->super.gate->brain;

		lu_user_assert_void(brain, "Lu_Brain is NULL");
		lu_user_assert_void(arr_count(brain->recs) > 0, "Lu_Brain has no recs");

		for (lu_size rec_i = 0; rec_i < arr_count(brain->recs); rec_i++)
			self->fill_data[rec_i] = NULL;
	}

	static Save_Wave save_wave_create(Gate gate, Save_Wave_Create_Opts opts)
	{
		lu_user_assert(opts->max_story_size_in_blocks > 0, "Option max_story_size_in_blocks should be greater than 0");
		lu_user_assert(gate, "Gate is NULL");

		Lu_Brain brain = gate->brain;

		lu_user_assert(brain, "Lu_Brain is NULL");

		Mem mem = brain->mem_perm;

		lu_user_assert(mem, "Mem is NULL");

		Save_Wave self 		= (Save_Wave) mem_alloc(mem, sizeof(struct save_wave));

		wave_init(&self->super, gate);

		lu_user_assert(self, "Unable to allocate Save_Wave");

		lu_user_assert(arr_count(brain->recs) > 0, "Lu_Brain has no recs");

		self->fill_data = (lu_p_value*) mem_alloc(mem, sizeof(lu_p_value*) * arr_count(brain->recs));

		save_wave_reset(self);

		return self;
	}

	static void save_wave_data_send(Save_Wave self, N_Rec n_rec, lu_p_value data, lu_size block_i)
	{
		lu_user_assert_void(self, "Lu_Wave is NULL");
		lu_user_assert_void(n_rec, "N_Rec is NULL");
		lu_user_assert_void(data, "Data is NULL");

		lu_size x, y, z;
		lu_value value;

		N_Col n_col;
		lu_size neu_ent = ENT_NULL;

		for(y = 0; y < n_rec->colors_h; y++)
			for(x = 0; x < n_rec->colors_w; x++)
			{
				n_col = n_rec_colors_get(n_rec, x, y);
				lu_user_assert_void(n_col, "N_Col is NULL");

				for(z = 0; z < n_rec->component_size; z++)
				{
					value = lu_data_get(data, n_rec->colors_w, n_rec->colors_h, n_rec->component_size, x, y, z);

					neu_ent = n_col_neu_ent_get(n_col, value);
					lu_user_assert_void(neu_ent, "Cannot get neu_ent for value");

					save_wave_c_neu_fire(self, neu_ent, value);
				}				
			}
	}

	static void save_wave_c_neu_fire(Save_Wave self, lu_size neu_ent, lu_value value)
	{

	}

	static void save_wave_rec_progress(Save_Wave wave, N_Rec n_rec, lu_size block_i)
	{

	}

	static void save_wave_block_progress(Save_Wave wave, lu_size block_i)
	{

	}