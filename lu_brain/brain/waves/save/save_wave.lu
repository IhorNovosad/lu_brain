/**
	Copyright Â© 2020 Oleh Ihorovych Novosad 
*/

///////////////////////////////////////////////////////////////////////////////
// Save_Wave_Create_Opts

	static void save_wave_create_opts_init(Save_Wave_Create_Opts self)
	{
		self->max_story_size_in_blocks = 16;
	}

///////////////////////////////////////////////////////////////////////////////
// Save_Wave

	static void save_wave_init(Save_Wave self, Lu_Story story, Lu_Save_Opts opts)
	{
		if (opts)
			self->save_opts = *opts;

		self->super.story = story;
	} 

	static void save_wave_reset(Save_Wave self)
	{
		lu_user_assert_void(self, "Lu_Wave is NULL");
		lu_user_assert_void(self->super.gate, "Gate is NULL");

		Lu_Brain brain = self->super.gate->brain;

		lu_user_assert_void(brain, "Lu_Brain is NULL");
		lu_user_assert_void(arr_count(brain->recs) > 0, "Lu_Brain has no recs");

		for (lu_size rec_i = 0; rec_i < arr_count(brain->recs); rec_i++)
			self->fill_data[rec_i] = NULL;
	}

	static Save_Wave save_wave_create(Gate gate, Save_Wave_Create_Opts opts)
	{
		lu_user_assert(opts->max_story_size_in_blocks > 0, "Option max_story_size_in_blocks should be greater than 0");
		lu_user_assert(gate, "Gate is NULL");

		Lu_Brain brain = gate->brain;

		lu_user_assert(brain, "Lu_Brain is NULL");

		Mem mem = brain->mem_perm;

		lu_user_assert(mem, "Mem is NULL");

		Save_Wave self 		= (Save_Wave) mem_alloc(mem, sizeof(struct save_wave));

		wave_init(&self->super, gate);

		lu_user_assert(self, "Unable to allocate Save_Wave");

		lu_user_assert(arr_count(brain->recs) > 0, "Lu_Brain has no recs");

		self->fill_data = (lu_p_value*) mem_alloc(mem, sizeof(lu_p_value*) * arr_count(brain->recs));

		save_wave_reset(self);

		return self;
	}

	// static inline bool w_rec_pos_valid(W_Rec self, int x, int y)
	// {
	// 	return x >= 0 && x < self->w_cols_w && y >= 0 && y < self->w_cols_h; 
	// }

	static void save_wave_data_send(Save_Wave self, Lu_Save_Opts opts, N_Rec n_rec, lu_p_value data, lu_size block_i)
	{
		lu_user_assert_void(self, "Lu_Wave is NULL");
		lu_user_assert_void(n_rec, "N_Rec is NULL");
		lu_user_assert_void(n_rec->rec, "N_Rec rec is NULL");
		lu_user_assert_void(data, "Data is NULL");

		lu_size x, y, z;
		lu_value value;

		Lu_Wave wave 		= &self->super;

		W_Rec w_rec 		= wave_w_rec_get(wave, n_rec->id);
		lu_user_assert_void(w_rec, "W_Rec is NULL");

		W_Col p_w_col 		= NULL;
		W_Col c_w_col1 		= NULL;
		W_Col c_w_col2 		= NULL;

		N_Col p_n_col		= NULL;
		N_Col c_n_col1  	= NULL;
		N_Col c_n_col2		= NULL;

		lu_size data_w 		= n_rec->rec->width;
		lu_size data_h 		= n_rec->rec->height;

		lu_size i, j;

		int x1, y1, x2, y2;
		lu_value vp[w_rec->component_size];

		lu_value vpsum, v1, v2;

		lu_value val_comp_size = (lu_value) w_rec->component_size;


		for(i = 0; i < arr_count(w_rec->pers); i++)
		{
			p_w_col = arr_get(w_rec->pers, i);

			lu_user_assert_void(p_w_col, "w_col is NULL");
			lu_user_assert_void(p_w_col->type == NCT_PER_HOR || p_w_col->type == NCT_PER_VER, "Something went wrong");

			if (p_w_col->type == NCT_PER_HOR)
			{
				x1 = p_w_col->x - 1;
				y1 = p_w_col->y;

				x2 = p_w_col->x + 1;
				y2 = p_w_col->y;

				c_w_col1 = w_rec_w_cols_get(w_rec, x1, y1);
				c_w_col2 = w_rec_w_cols_get(w_rec, x2, y2);
			}
			else
			{
				x1 = p_w_col->x;
				y1 = p_w_col->y - 1;

				x2 = p_w_col->x;
				y2 = p_w_col->y + 1;

				c_w_col1 = w_rec_w_cols_get(w_rec, x1, y1);
				c_w_col2 = w_rec_w_cols_get(w_rec, x2, y2);
			}

			lu_user_assert_void(c_w_col1 && c_w_col1->type == NCT_COL, "Something went wrong");
			lu_user_assert_void(c_w_col2 && c_w_col2->type == NCT_COL, "Something went wrong");

			for (j = 0; j < w_rec->component_size; j++)
			{
				v1 = lu_data_get(data, data_w, data_h, w_rec->component_size, c_w_col1->x, c_w_col1->y, j);
				v2 = lu_data_get(data, data_w, data_h, w_rec->component_size, c_w_col2->x, c_w_col2->y, j);

				vp[j] = lu_value_abs(v1 - v2);
				vpsum += vp[j];
			}

			if ((vpsum / val_comp_size) >= opts->contrast)
			{
				p_n_col = n_rec_n_cols_get(n_rec, p_w_col->x, p_w_col->y);
				c_n_col1 = n_rec_n_cols_get(n_rec, c_w_col1->x, c_w_col1->y);
				c_n_col2 = n_rec_n_cols_get(n_rec, c_w_col2->x, c_w_col2->y);

				//neu_ent = n_col_neu_ent_get(n_col, value);
			}
		}

		// porahuvaty potochni __val__ dlia vsih w_col
		// porahuvaty perepady dlia vsih w_col z prev
		// tilky dlia perepadiv po chasu i prostoru znayty c i p neus i sformuvaty t-neu
		// for(y = 0; y < w_rec->pers_h; y++)
		// 	for(x = 0; x < w_rec->pers_w; x++)
		// 	{
		// 		w_col = w_rec_pers_get(w_rec, x, y);
		// 		lu_user_assert_void(w_col, "W_Col is NULL");
				
		// 		// for(z = 0; z < w_rec->component_size; z++)
		// 		// {
		// 		// 	// we are assuming data sizes and w_rec->pers sizes are the same
		// 		// 	value = lu_data_get(data, data_w, data_h, w_rec->component_size, x, y, z);

		// 		// 	//w_col->curr_vals[z] = value;
		// 		// }
		// 	}


				// 		n_col = n_rec_pers_get(n_rec, x, y);
		// 		lu_user_assert_void(n_col, "N_Col is NULL");

		// 		for(z = 0; z < n_rec->component_size; z++)
		// 		{
		// 			value = lu_data_get(data, n_rec->pers_w, n_rec->pers_h, n_rec->component_size, x, y, z);

		// 			neu_ent = n_col_neu_ent_get(n_col, value);
		// 			lu_user_assert_void(neu_ent, "Cannot get neu_ent for value");

		// 			//save_wave_c_neu_fire(self, neu_ent, value);
	}

	static void save_wave_c_neu_fire(Save_Wave self, lu_size neu_ent, lu_value value)
	{

	}

	static void save_wave_rec_progress(Save_Wave wave, N_Rec n_rec, lu_size block_i)
	{

	}

	static void save_wave_block_progress(Save_Wave wave, lu_size block_i)
	{

	}