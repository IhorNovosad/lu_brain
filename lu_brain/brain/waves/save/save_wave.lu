/**
	Copyright Â© 2020 Oleh Ihorovych Novosad 
*/

///////////////////////////////////////////////////////////////////////////////
// Save_Wave_Create_Opts

	static void save_wave_create_opts_init(Save_Wave_Create_Opts self)
	{
		self->max_story_size_in_blocks = 16;
	}

///////////////////////////////////////////////////////////////////////////////
// Save_Wave

	static void save_wave_init(Save_Wave self, Lu_Story story, Lu_Save_Opts opts)
	{
		if (opts)
			self->save_opts = *opts;

		self->super.story = story;
	} 

	static void save_wave_reset(Save_Wave self)
	{
		lu_user_assert_void(self, "Lu_Wave is NULL");
		lu_user_assert_void(self->super.gate, "Gate is NULL");

		Lu_Brain brain = self->super.gate->brain;

		lu_user_assert_void(brain, "Lu_Brain is NULL");
		lu_user_assert_void(arr_count(brain->recs) > 0, "Lu_Brain has no recs");

		for (lu_size rec_i = 0; rec_i < arr_count(brain->recs); rec_i++)
			self->fill_data[rec_i] = NULL;
	}

	static Save_Wave save_wave_create(Gate gate, Save_Wave_Create_Opts opts)
	{
		lu_user_assert(opts->max_story_size_in_blocks > 0, "Option max_story_size_in_blocks should be greater than 0");
		lu_user_assert(gate, "Gate is NULL");

		Lu_Brain brain = gate->brain;

		lu_user_assert(brain, "Lu_Brain is NULL");

		Mem mem = brain->mem_perm;

		lu_user_assert(mem, "Mem is NULL");

		Save_Wave self 		= (Save_Wave) mem_alloc(mem, sizeof(struct save_wave));

		wave_init(&self->super, gate);

		lu_user_assert(self, "Unable to allocate Save_Wave");

		lu_user_assert(arr_count(brain->recs) > 0, "Lu_Brain has no recs");

		self->fill_data = (lu_p_value*) mem_alloc(mem, sizeof(lu_p_value*) * arr_count(brain->recs));

		save_wave_reset(self);

		return self;
	}

	// static inline bool w_rec_pos_valid(W_Rec self, int x, int y)
	// {
	// 	return x >= 0 && x < self->w_cols_w && y >= 0 && y < self->w_cols_h; 
	// }

	static void save_wave_data_send(Save_Wave self, Lu_Save_Opts opts, N_Rec n_rec, lu_p_value data, lu_size block_i)
	{
		lu_user_assert_void(self, "Lu_Wave is NULL");
		lu_user_assert_void(n_rec, "N_Rec is NULL");
		lu_user_assert_void(n_rec->rec, "N_Rec rec is NULL");
		lu_user_assert_void(data, "Data is NULL");

		Lu_Wave wave 		= &self->super;

		W_Rec w_rec 		= wave_w_rec_get(wave, n_rec->id);
		lu_user_assert_void(w_rec, "W_Rec is NULL");

		// W_Col p_w_col 		= NULL;
		// W_Col c_w_col1 		= NULL;
		// W_Col c_w_col2 		= NULL;

		// N_Col p_n_col		= NULL;
		// N_Col c_n_col1  		= NULL;
		// N_Col c_n_col2		= NULL;

		lu_size data_w 		= n_rec->rec->width;
		lu_size data_h 		= n_rec->rec->height;

		lu_value val_comp_size = (lu_value) w_rec->component_size;

		// ce ne zovsim pravylno, bo kozhna n_col takozh mozhe maty t perep,
		// tomu odnakovo treba proytysia po vsih 

		lu_size x, y, j, dx, dy;
		N_Col n_col = NULL;

		n_rec_debug_print(n_rec); 

		lu_value v;

		if (block_i == 0) 
		{
			// zmin po chasu nema, tomu mo
		}

		// prohodymsia po vsih prostorovyh perepadah, obchysluyemo yih
		// (yaksho block_i != 0 obchysluyemo chasovi perepady)
		// paralelno formuyemo chetvirky dlia perepadiv (2 i 4)
		// pochynayemo buduvaty piramidy dlia kozhnoyi hrupy chetvirok (yaksho v niy ye hocha b odyn neu)

		for (y = 0; y < n_rec->n_cols_h; y++)
			for (x = 0; x < n_rec->n_cols_w; x++)
			{
				n_col = n_rec_n_cols_get(n_rec, x, y);

				// lu_debug("\n n_col (%d, %d)", x, y);
				// lu_user_assert_void(n_col, "N_Col is NULL");

				if (n_col == NULL) continue;

				dx = n_col->data_x;
				dy = n_col->data_y;

				for (j = 0; j < n_rec->component_size; j++)
				{
					v = lu_data_get(data, data_w, data_h, n_rec->component_size, dx, dy, j);
				}	

				
			} 


		// for (y = 0; y < w_rec->w_cols_h; y++)
		// 	for (x = 0; x < w_rec->w_cols_w; x++)
		// 	{

		// 		col = w_rec_w_cols_get(w_rec, x, y);

		// 		for (j = 0; j < w_rec->component_size; j++)
		// 		{
		// 			lu_debug("\n TTT: %d, %d, %d, %d", x, y, data_w, data_h);
		// 			v = lu_data_get(data, data_w, data_h, w_rec->component_size, col->x, col->y, j);
		// 			///col->curr_vals[j] = v;
		// 		}	

				// p_w_col = arr_get(w_rec->pers, i);

				// lu_user_assert_void(p_w_col, "w_col is NULL");
				// lu_user_assert_void(p_w_col->type == NCT_PER_HOR || p_w_col->type == NCT_PER_VER, "Something went wrong");

				// if (p_w_col->type == NCT_PER_HOR)
				// {
				// 	x1 = p_w_col->x - 1;
				// 	y1 = p_w_col->y;

				// 	x2 = p_w_col->x + 1;
				// 	y2 = p_w_col->y;

				// 	c_w_col1 = w_rec_w_cols_get(w_rec, x1, y1);
				// 	c_w_col2 = w_rec_w_cols_get(w_rec, x2, y2);
				// }
				// else
				// {
				// 	x1 = p_w_col->x;
				// 	y1 = p_w_col->y - 1;

				// 	x2 = p_w_col->x;
				// 	y2 = p_w_col->y + 1;

				// 	c_w_col1 = w_rec_w_cols_get(w_rec, x1, y1);
				// 	c_w_col2 = w_rec_w_cols_get(w_rec, x2, y2);
				// }

				// lu_user_assert_void(c_w_col1 && c_w_col1->type == NCT_COL, "Something went wrong");
				// lu_user_assert_void(c_w_col2 && c_w_col2->type == NCT_COL, "Something went wrong");

				// for (j = 0; j < w_rec->component_size; j++)
				// {
				// 	v1 = lu_data_get(data, data_w, data_h, w_rec->component_size, c_w_col1->x, c_w_col1->y, j);
				// 	v2 = lu_data_get(data, data_w, data_h, w_rec->component_size, c_w_col2->x, c_w_col2->y, j);

				// 	vp[j] = lu_value_abs(v1 - v2);
				// 	vpsum += vp[j];
				// }

				// if ((vpsum / val_comp_size) >= opts->contrast)
				// {
				// 	p_n_col		= n_rec_n_cols_get(n_rec, p_w_col->x, p_w_col->y);
				// 	c_n_col1 	= n_rec_n_cols_get(n_rec, c_w_col1->x, c_w_col1->y);
				// 	c_n_col2 	= n_rec_n_cols_get(n_rec, c_w_col2->x, c_w_col2->y);


				// 	//neu_ent = n_col_neu_ent_get(n_col, value);
				// }
			// }

		// porahuvaty potochni __val__ dlia vsih w_col
		// porahuvaty perepady dlia vsih w_col z prev
		// tilky dlia perepadiv po chasu i prostoru znayty c i p neus i sformuvaty t-neu
		// for(y = 0; y < w_rec->pers_h; y++)
		// 	for(x = 0; x < w_rec->pers_w; x++)
		// 	{
		// 		w_col = w_rec_pers_get(w_rec, x, y);
		// 		lu_user_assert_void(w_col, "W_Col is NULL");
				
		// 		// for(z = 0; z < w_rec->component_size; z++)
		// 		// {
		// 		// 	// we are assuming data sizes and w_rec->pers sizes are the same
		// 		// 	value = lu_data_get(data, data_w, data_h, w_rec->component_size, x, y, z);

		// 		// 	//w_col->curr_vals[z] = value;
		// 		// }
		// 	}


				// 		n_col = n_rec_pers_get(n_rec, x, y);
		// 		lu_user_assert_void(n_col, "N_Col is NULL");

		// 		for(z = 0; z < n_rec->component_size; z++)
		// 		{
		// 			value = lu_data_get(data, n_rec->pers_w, n_rec->pers_h, n_rec->component_size, x, y, z);

		// 			neu_ent = n_col_neu_ent_get(n_col, value);
		// 			lu_user_assert_void(neu_ent, "Cannot get neu_ent for value");

		// 			//save_wave_c_neu_fire(self, neu_ent, value);
	}

	static void save_wave_c_neu_fire(Save_Wave self, lu_size neu_ent, lu_value value)
	{

	}

	static void save_wave_rec_progress(Save_Wave wave, N_Rec n_rec, lu_size block_i)
	{

	}

	static void save_wave_block_progress(Save_Wave wave, lu_size block_i)
	{

	}