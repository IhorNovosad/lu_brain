/**
	Copyright Â© 2020 Oleh Ihorovych Novosad 
*/

///////////////////////////////////////////////////////////////////////////////
// Includes

	#include "block.lu"
 
///////////////////////////////////////////////////////////////////////////////
// Create and destroy

	Story lu_story_create(Brain brain, lu_size story_size_in_blocks)
	{
		lu_user_assert(brain, "Brain should not be NULL");
		lu_user_assert(
			brain->recs && arr_count(brain->recs), 
			"Brain recs should be created first"
		);

		Story self 		= (Story) mem_alloc(g_mem_temp, sizeof(struct story));

		// Initialize
		self->brain 	= brain;

		lu_size w 		= arr_count(self->brain->recs);
		lu_size h 		= story_size_in_blocks == 0 ? STORY_INITIAL_BLOCKS_SIZE : story_size_in_blocks;
		self->data 		= arr2_create(g_mem_temp, w, h);

		lu_size x, y;
		Rec rec;

		story_reset(self);

		return self;
	}

	void lu_story_destroy(Story self)
	{
		lu_user_assert_void(self, "Story is NULL");

		arr2_destroy(self->data, g_mem_temp);
		mem_free(g_mem_temp, (lu_p_byte) self);
	}

///////////////////////////////////////////////////////////////////////////////
// API

	void lu_story_push(Story self, Rec rec, lu_value* data)
	{
		lu_user_assert_void(self, "story should not be NULL"); 
		lu_user_assert_void(rec, "rec should not be NULL"); 
		lu_user_assert_void(data, "data should not be NULL");
		lu_user_assert_void(rec->depth, "rec->depth is out of range");


		if (self->start_block_on_next_data)
		{ 
			// yaksho my na nuliu, to ce itak pochatok bloka
			if (self->block_count)
				++self->data_y;	
			
			self->start_block_on_next_data = false;
		}
	
		lu_p_value v = arr2_get(self->data, rec->id, self->data_y);
		if (v) 
			// new input to the same rec and channel advances story
			++self->data_y;
			
 		lu_user_assert_void(
 			self->data_y < arr2_height(self->data), 
 			"Out of available blocks in story."
 		); 

 		arr2_set(self->data, rec->id, self->data_y, (lu_p_void) data);

 		self->block_count = self->data_y + 1;
	} 

	static void story_reset(Story self)
	{
		lu_user_assert_void(self, "Story should be present");
		lu_user_assert_void(self->brain, "Story brain should be present");
		lu_user_assert_void(self->data, "Story data should be present");

		lu_size block_i, rec_i;
		Arr2 data = self->data;
		Rec rec;
		Brain brain = self->brain;

		for(block_i = 0; block_i <= self->data_y; block_i++)
			for(rec_i = 0; rec_i < arr2_width(data); rec_i++)
				arr2_set(data, rec_i, block_i, NULL);


		self->data_y = 0;
		self->start_block_on_next_data = false; 
		self->block_count = 0;
	}

	Wave lu_story_save_async(Story self, Save_Opts opts)
	{
		lu_user_assert(self, "Story should not be NULL");
		lu_user_assert(opts, "Save_Opts is NULL");

		lu_debug("\nSAVE (block_count = %lu)\n", self->block_count);

		Brain brain = self->brain;
		lu_user_assert(brain, "Story not linked to brain");

		Arr recs = brain->recs;

		lu_user_assert(recs, "Brain has no recs");
		lu_user_assert(arr_count(recs), "Brain has no recs1");
		lu_user_assert(self->block_count, "Story without blocks");

		Gate gate = brain_gate(self->brain);

		// my reset wave v gate_save_wave_wait
		Save_Wave wave = gate_save_wave_wait(gate);

		save_wave_init(wave, self, opts);

		lu_size block_i, rec_i;
		
		lu_p_value prev_d;
		lu_p_value curr_d;
		lu_p_value next_d;
		lu_p_value fill_d;

		Rec rec; 
		Arr2 data = self->data;

		for(rec_i = 0; rec_i < arr2_width(data); rec_i++)
		{
			rec 	= lu_brain_rec_get(brain, rec_i);

			for(block_i = 0; block_i < self->block_count; block_i++)
			{
				curr_d = arr2_get(data, rec_i, block_i);

				if (curr_d) {
					wave->fill_data[rec_i] = curr_d;
					break; 
				}
			}

			if (wave->fill_data[rec_i] == NULL)
				lu_user_debug_args("Story has no data for rec %lu", rec_i);
		
		}

		// for(rec_i = 0; rec_i < arr2_width(data); rec_i++)
		// {
		// 	rec 	= lu_brain_rec_get(brain, rec_i);
		// 	last_ch = wave->fill_data[rec_i];

		// 	for (chan_i = 0; chan_i < rec->depth;  chan_i++)
		// 	{
		// 		curr_d = arr_get(last_ch, chan_i);

		// 		if (curr_d)
		// 			lu_debug("\nLAST_CH(rec=%lu, chan_i=%lu): %.0f", rec_i, chan_i, curr_d[0]);
		// 		else
		// 			lu_debug("\nLAST_CH(rec=%lu, chan_i=%lu): NULL", rec_i, chan_i);
		// 	}
		// }

		// naspravdi meni ne potriben prev i next, dostatnio tilky curr
		// curr doyednuyetsia do poperednih danyh. My skorishe mayemo
		// opraciovuvaty vsi channel dlia potochnoho bloku i rec 
		// odnochasno - bo vsi channel formuyut piksel
		// hiba dlia toho shob porahuvaty cont
		for(block_i = 0; block_i < self->block_count; block_i++)
		{
			for(rec_i = 0; rec_i < arr2_width(data); rec_i++)
			{
				rec 	= lu_brain_rec_get(brain, rec_i);
				curr_d 	= arr2_get(data, rec_i, block_i);

				if (curr_d)
					wave->fill_data[rec_i] = curr_d;
				else 
					curr_d = wave->fill_data[rec_i];


				lu_debug("\n DATA(block=%lu, rec=%lu): ", block_i, rec_i);
				curr_d ? lu_debug("%.0f ", curr_d[0]) : lu_debug("NULL ");

				// process


			}
		}


		story_reset(self);


		return (Wave) wave;
	}

	Save_Resp lu_story_save(Story self, Save_Opts opts)
	{
		lu_user_assert(self, "Story is NULL");
		lu_user_assert(opts, "Save_Opts is NULL");

		Wave wave = lu_story_save_async(self, opts);
		
		lu_wave_join(wave);

		return (Save_Resp) lu_wave_response(wave);
	}

	Wave lu_story_find_async(Story self, Find_Opts opts)
	{
		lu_user_assert(self, "Story is NULL");
		lu_user_assert(opts, "Find_Opts is NULL");

		Gate gate = brain_gate(self->brain);

		Find_Wave wave = gate_find_wave_wait(gate);

		find_wave_init(wave, self, opts);

		find_wave_process(wave);

		return (Wave) wave;
	}

	Find_Resp lu_story_find(Story self, Find_Opts opts)
	{
		lu_user_assert(self, "Story is NULL");
		lu_user_assert(opts, "Find_Opts is NULL");

		Wave wave = lu_story_find_async(self, opts);
		
		lu_wave_join(wave);

		return (Find_Resp) lu_wave_response(wave);
	}

	Wave lu_story_restore_async(Brain brain, Neuron neuron, Restore_Opts opts)
	{ 
		lu_user_assert(brain, "Brain is NULL");
		lu_user_assert(neuron, "Neuron is NULL");
		lu_user_assert(opts, "Restore_Opts is NULL");

		Gate gate = brain_gate(brain);

		Restore_Wave wave = gate_restore_wave_wait(gate);

		restore_wave_init(wave, brain, opts);

		restore_wave_process(wave);

		return (Wave) wave;
	}

	Restore_Resp lu_story_restore(Brain brain, Neuron neuron, Restore_Opts opts)
	{
		lu_user_assert(brain, "Brain is NULL");
		lu_user_assert(neuron, "Neuron is NULL");
		lu_user_assert(opts, "Restore_Opts is NULL");

		Wave wave = lu_story_restore_async(brain, neuron, opts);
		
		lu_wave_join(wave);

		return (Restore_Resp) lu_wave_response(wave);
	}

