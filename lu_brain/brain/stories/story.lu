
 
///////////////////////////////////////////////////////////////////////////////
// Create and destroy

	Story lu_story_create(Brain brain, lu_size story_size_in_blocks)
	{
		lu_user_assert(brain, "Brain should not be NULL");
		lu_user_assert(
			brain->recs && arr_count(brain->recs), 
			"Brain recs should be created first"
		);

		Story self 		= (Story) mem_alloc(g_mem_temp, sizeof(struct story));

		// Initialize
		self->brain 	= brain;

		lu_size w 		= arr_count(self->brain->recs);
		lu_size h 		= story_size_in_blocks == 0 ? STORY_INITIAL_BLOCKS_SIZE : story_size_in_blocks;
		self->data 		= arr2_create(g_mem_temp, w, h);

		lu_size x, y;
		Rec rec;
		Arr channels;
		for(y = 0; y < h; y++)
			for(x = 0; x < w; x++)
			{
				rec = lu_brain_rec_get(brain, x);
				channels = arr_create(brain->mem_perm, rec->channel_size);

				arr2_set(self->data, x, y, channels);
			}


		story_reset(self);

		return self;
	}

	void lu_story_destroy(Story self)
	{
		lu_user_assert_void(self, "Story is NULL");

		arr2_destroy(self->data, g_mem_temp);
		mem_free(g_mem_temp, (lu_p_byte) self);
	}

///////////////////////////////////////////////////////////////////////////////
// API

	void lu_story_push(Story self, Rec rec, lu_size channel_index, lu_value* data)
	{
		lu_user_assert_void(self, "story should not be NULL"); 
		lu_user_assert_void(rec, "rec should not be NULL"); 
		lu_user_assert_void(data, "data should not be NULL");
		lu_user_assert_void(channel_index < rec->channel_size, "channel_index is out of range");

		Arr channels;

		if (self->start_block_on_next_data)
		{ 
			// yaksho my na nuliu, to ce itak pochatok bloka
			if (self->block_count)
			{
				++self->data_y;	
			}

			self->start_block_on_next_data = false;
		}
	
		channels = (Arr) arr2_get(self->data, rec->id, self->data_y);
		lu_p_value v = arr_get(channels, channel_index);
		if (v) 
		{
			// new input to the same rec and channel advances story
			++self->data_y;
			channels = (Arr) arr2_get(self->data, rec->id, self->data_y);
		}
 
 		lu_user_assert_void(
 			self->data_y < arr2_height(self->data), 
 			"Out of available blocks in story."
 		); 

 		arr_set(channels, channel_index, (lu_p_void) data);

 		self->block_count = self->data_y + 1;
	} 

	static void story_reset(Story self)
	{
		lu_user_assert_void(self, "Story should be present");
		lu_user_assert_void(self->brain, "Story brain should be present");
		lu_user_assert_void(self->data, "Story data should be present");

		lu_size yi, xi, i;
		Arr curr_ch;
		Arr2 data = self->data;
		Rec rec;
		Brain brain = self->brain;

		for(yi = 0; yi <= self->data_y; yi++)
		{
			for(xi = 0; xi < arr2_width(data); xi++)
			{
				rec 	= lu_brain_rec_get(brain, xi);
				curr_ch = (Arr) arr2_get(data, xi, yi);

				for(i = 0; i < rec->channel_size; i++)
				{
					arr_set(curr_ch, i, NULL);
				}
			}
		}

		self->data_y = 0;
		self->start_block_on_next_data = false; 
		self->block_count = 0;
	}

	mv_alg Wave lu_story_save_async(Story self, Save_Opts opts)
	{
		lu_user_assert(self, "Story should not be NULL");
		lu_user_assert(opts, "Save_Opts is NULL");

		lu_debug("\nSAVE (block_count = %lu)\n", self->block_count);

		Brain brain = self->brain;
		lu_user_assert(brain, "Story not linked to brain");

		Arr recs = brain->recs;

		lu_user_assert(recs, "Brain has no recs");
		lu_user_assert(arr_count(recs), "Brain has no recs1");
		lu_user_assert(self->block_count, "Story without blocks");

		Gate gate = brain_gate(self->brain);

		// my reset wave v gate_save_wave_wait
		Save_Wave wave = gate_save_wave_wait(gate);

		save_wave_init(wave, self, opts);

		// Dlia choho stvoruvaty percepciyi chy she shos koly vse mozhna 
		// rahuvaty dynamichno? My dynamichno mozhemo rahuvaty contrasty
		// abo kolir

		// data x = recs, y - blocks 
		// [x,y] - channels
		// channel[i] = channel data

		lu_size xi, yi;
		lu_size i;
		
		Arr prev_ch;
		Arr curr_ch;
		Arr next_ch;
		
		lu_p_value prev_d;
		lu_p_value curr_d;
		lu_p_value next_d;

		Rec rec; 
		Arr2 data = self->data;

		for(yi = 0; yi < self->block_count; yi++)
		{
			for(xi = 0; xi < arr2_width(data); xi++)
			{
				rec 	= lu_brain_rec_get(brain, xi);

				prev_ch = yi ? (Arr) arr2_get(data, xi, yi - 1) : NULL;
				curr_ch = (Arr) arr2_get(data, xi, yi);
				next_ch = yi + 1 < arr2_height(data) ?  (Arr) arr2_get(data, xi, yi + 1) : NULL;

				for(i = 0; i < rec->channel_size; i++)
				{
					prev_d = prev_ch ? arr_get(prev_ch, i) : NULL;
					curr_d = curr_ch ? arr_get(curr_ch, i) : NULL;
					next_d = next_ch ? arr_get(next_ch, i) : NULL;
 
					lu_debug("\n DATA(y=%lu, rec=%lu, ch=%lu): ", yi, xi, i);
					prev_d ? lu_debug("PRESENT ") : lu_debug("NULL ");
					curr_d ? lu_debug("PRESENT ") : lu_debug("NULL ");
					next_d ? lu_debug("PRESENT ") : lu_debug("NULL ");

				}

			} 
		}

		story_reset(self);


		// Zbuduvaty neus dlia percepciy

		// Zbuduvaty neus dlia neus percepciy 



		//arr_each_with_index_1p(story->blocks, save_wave_each_block_save, self);

		return (Wave) wave;
	}

	mv_setup Save_Resp lu_story_save(Story self, Save_Opts opts)
	{
		lu_user_assert(self, "Story is NULL");
		lu_user_assert(opts, "Save_Opts is NULL");

		Wave wave = lu_story_save_async(self, opts);
		
		lu_wave_join(wave);

		return (Save_Resp) lu_wave_response(wave);
	}

	Wave lu_story_find_async(Story self, Find_Opts opts)
	{
		lu_user_assert(self, "Story is NULL");
		lu_user_assert(opts, "Find_Opts is NULL");

		Gate gate = brain_gate(self->brain);

		Find_Wave wave = gate_find_wave_wait(gate);

		find_wave_init(wave, self, opts);

		find_wave_process(wave);

		return (Wave) wave;
	}

	Find_Resp lu_story_find(Story self, Find_Opts opts)
	{
		lu_user_assert(self, "Story is NULL");
		lu_user_assert(opts, "Find_Opts is NULL");

		Wave wave = lu_story_find_async(self, opts);
		
		lu_wave_join(wave);

		return (Find_Resp) lu_wave_response(wave);
	}

	Wave lu_story_restore_async(Brain brain, Neuron neuron, Restore_Opts opts)
	{ 
		lu_user_assert(brain, "Brain is NULL");
		lu_user_assert(neuron, "Neuron is NULL");
		lu_user_assert(opts, "Restore_Opts is NULL");

		Gate gate = brain_gate(brain);

		Restore_Wave wave = gate_restore_wave_wait(gate);

		restore_wave_init(wave, brain, opts);

		restore_wave_process(wave);

		return (Wave) wave;
	}

	Restore_Resp lu_story_restore(Brain brain, Neuron neuron, Restore_Opts opts)
	{
		lu_user_assert(brain, "Brain is NULL");
		lu_user_assert(neuron, "Neuron is NULL");
		lu_user_assert(opts, "Restore_Opts is NULL");

		Wave wave = lu_story_restore_async(brain, neuron, opts);
		
		lu_wave_join(wave);

		return (Restore_Resp) lu_wave_response(wave);
	}

