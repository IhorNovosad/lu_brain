
 
///////////////////////////////////////////////////////////////////////////////
// Create and destroy

	Story story_create(Brain brain, lu_size story_size_in_blocks)
	{
		if (brain == NULL)
			return lu_user_throw("Brain should not be NULL");

		if (brain->recs == NULL || arr_count(brain->recs) < 1)
			return lu_user_throw("Brain recs should be created first");

		Story self 		= (Story) mem_alloc(g_mem_temp, sizeof(struct story));

		// Initialize
		self->brain 	= brain;

		lu_size w 		= arr_count(self->brain->recs);
		lu_size h 		= story_size_in_blocks == 0 ? STORY_INITIAL_BLOCKS_SIZE : story_size_in_blocks;
		self->data 		= arr2_create(g_mem_temp, w, h);

		lu_size x, y;
		for(y = 0; y < h; y++)
			for(x = 0; x < w; x++)
			{
				arr2_set(self->data, x, y, NULL);
			}

		self->data_y 	= 0;

		return self;
	}

	void story_destroy(Story self)
	{
		arr2_destroy(self->data, g_mem_temp);
		mem_free(g_mem_temp, (lu_p_byte) self);
	}

///////////////////////////////////////////////////////////////////////////////
// API

	void story_push(Story self, Rec rec, lu_value* data)
	{
		if (self == NULL) { lu_user_throw("Story should not be NULL"); return; }
		if (rec == NULL) { lu_user_throw("Rec should not be NULL"); return; }
		if (data == NULL) { lu_user_throw("Data should not be NULL"); return; }

		// new inpute to the same rec advances story
		if (arr2_get(self->data, rec->id, self->data_y) != NULL) ++self->data_y;
 
 		if (self->data_y >= arr2_height(self->data)) 
 			{ lu_user_throw("Out of available blocks in story."); return; }

		arr2_set(self->data, rec->id, self->data_y, (lu_p_void) data);
	}


	mv_alg Wave story_save_async(Story self, Save_Opts opts)
	{
		if (self == NULL) 
			return lu_user_throw("Story should not be NULL");

		Brain brain = self->brain;
		if (brain == NULL)
			return lu_user_throw("Story has no like to brain");

		Arr recs = brain->recs;

		if (recs == NULL || arr_size(recs) < 1)
			return lu_user_throw("Brain has no recs");

		if (self->data_y < 1) 
			return lu_user_throw("Story without blocks");

		Gate gate = brain_gate(self->brain);

		Save_Wave wave = gate_save_wave_wait(gate);

		save_wave_init(wave, self, opts);

		// Stvoryty percepciyi

		lu_size xi, yi, x, y;
		lu_p_value prev;
		lu_p_value curr;
		lu_p_value next;
		Rec rec; 
		Arr2 data = self->data;

		for(xi = 0; xi < arr2_width(data); xi++)
		{
			rec = lu_brain_rec_get(brain, xi);

			for(yi = 0; yi < arr2_height(data); yi++)
			{
				if (yi - 1 < 0)
					prev = NULL;
				else 
					prev = (lu_p_value) arr2_get(data, xi, yi - 1);

				curr = (lu_p_value) arr2_get(data, xi, yi);

				if (yi + 1 >= arr2_height(data))
					next = NULL;
				else
					next = (lu_p_value) arr2_get(data, xi, yi + 1);

				// lu_p_value perc = perc_cont_create(rec, prev, curr, next);

				// arr2_set(wave->percs, xi, yi, perc);
			} 
		}


		// Zbuduvaty neus dlia percepciy

		// Zbuduvaty neus dlia neus percepciy 



		//arr_each_with_index_1p(story->blocks, save_wave_each_block_save, self);

		return (Wave) wave;
	}

	mv_setup Save_Resp story_save(Story self, Save_Opts opts)
	{
		Wave wave = story_save_async(self, opts);
		
		wave_join(wave);

		return (Save_Resp) wave_response(wave);
	}

	Wave story_find_async(Story self, Find_Opts opts)
	{
		Gate gate = brain_gate(self->brain);

		Find_Wave wave = gate_find_wave_wait(gate);

		find_wave_init(wave, self, opts);

		find_wave_process(wave);

		return (Wave) wave;
	}

	Find_Resp story_find(Story self, Find_Opts opts)
	{
		Wave wave = story_find_async(self, opts);
		
		wave_join(wave);

		return (Find_Resp) wave_response(wave);
	}

	Wave story_restore_async(Brain brain, Neuron neuron, Restore_Opts opts)
	{ 
		Gate gate = brain_gate(brain);

		Restore_Wave wave = gate_restore_wave_wait(gate);

		restore_wave_init(wave, brain, opts);

		restore_wave_process(wave);

		return (Wave) wave;
	}

	Restore_Resp story_restore(Brain brain, Neuron neuron, Restore_Opts opts)
	{
		Wave wave = story_restore_async(brain, neuron, opts);
		
		wave_join(wave);

		return (Restore_Resp) wave_response(wave);
	}

