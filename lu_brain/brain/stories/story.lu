
 
///////////////////////////////////////////////////////////////////////////////
// Create and destroy

	Story lu_story_create(Brain brain, lu_size story_size_in_blocks)
	{
		lu_user_assert(brain, "Brain should not be NULL");
		lu_user_assert(
			brain->recs && arr_count(brain->recs), 
			"Brain recs should be created first"
		);

		Story self 		= (Story) mem_alloc(g_mem_temp, sizeof(struct story));

		// Initialize
		self->brain 	= brain;

		lu_size w 		= arr_count(self->brain->recs);
		lu_size h 		= story_size_in_blocks == 0 ? STORY_INITIAL_BLOCKS_SIZE : story_size_in_blocks;
		self->data 		= arr2_create(g_mem_temp, w, h);
		self->data_y 	= 0;

		lu_size x, y;
		Rec rec;
		Arr channels;
		for(y = 0; y < h; y++)
			for(x = 0; x < w; x++)
			{
				rec = lu_brain_rec_get(brain, x);
				channels = arr_create(brain->mem_perm, rec->channel_size);

				arr2_set(self->data, x, y, channels);
			}

		return self;
	}

	void lu_story_destroy(Story self)
	{
		lu_user_assert_void(self, "Story is NULL");

		arr2_destroy(self->data, g_mem_temp);
		mem_free(g_mem_temp, (lu_p_byte) self);
	}

///////////////////////////////////////////////////////////////////////////////
// API

	void lu_story_push(Story self, Rec rec, lu_size channel_index, lu_value* data)
	{
		lu_user_assert_void(self, "story should not be NULL"); 
		lu_user_assert_void(rec, "rec should not be NULL"); 
		lu_user_assert_void(data, "data should not be NULL");
		lu_user_assert_void(channel_index < rec->channel_size, "channel_index is out of range");

		Arr channels = (Arr) arr2_get(self->data, rec->id, self->data_y);

		// new input to the same rec and channel advances story
		if (arr_get(channels, channel_index) != NULL) 
		{
			++self->data_y;
			channels = (Arr) arr2_get(self->data, rec->id, self->data_y);
		}
 
 		lu_user_assert_void(
 			self->data_y < arr2_height(self->data), 
 			"Out of available blocks in story."
 		); 

 		arr_set(channels, channel_index, (lu_p_void) data);
	} 

 	static void cont_perc_calc(lu_p_value cont_perc, lu_p_value prev, lu_p_value curr, lu_p_value next)
 	{

 	}

	mv_alg Wave lu_story_save_async(Story self, Save_Opts opts)
	{
		lu_user_assert(self, "Story should not be NULL");
		lu_user_assert(opts, "Save_Opts is NULL");

		Brain brain = self->brain;
		lu_user_assert(brain, "Story not linked to brain");

		Arr recs = brain->recs;

		lu_user_assert(recs, "Brain has no recs");
		lu_user_assert(arr_count(recs), "Brain has no recs1");
		lu_user_assert(self->data_y, "Story without blocks");

		Gate gate = brain_gate(self->brain);

		Save_Wave wave = gate_save_wave_wait(gate);

		save_wave_init(wave, self, opts);

		// Stvoryty percepciyi

		// lu_size xi, yi, x, y;
		// lu_p_value prev;
		// lu_p_value curr;
		// lu_p_value next;
		// Rec rec; 
		// Arr2 data = self->data;
		// lu_p_value curr_cont;

		// lu_size rec_width, rec_height;

		// for(yi = 0; yi < arr2_height(data); yi++)
		// {
		// 	for(xi = 0; xi < arr2_width(data); xi++)
		// 	{
		// 		rec 		= lu_brain_rec_get(brain, xi);
		// 		curr_cont 	= arr2_get(wave->cont_percs, xi, yi);

		// 		if (yi == 0)
		// 			prev = NULL;
		// 		else 
		// 			prev = (lu_p_value) arr2_get(data, xi, yi - 1);

		// 		curr = (lu_p_value) arr2_get(data, xi, yi);

		// 		if (yi + 1 >= arr2_height(data))
		// 			next = NULL;
		// 		else
		// 			next = (lu_p_value) arr2_get(data, xi, yi + 1);

		// 		// treba stvroruvaty v wave masyvy i tudy spochatku 
		// 		// rahuvaty contr. Musymo spochatku porahuvaty contrasty
		// 		// Mozhna rahuvaty vykorystovuyuchy nearal net, ale 
		// 		// ne oboviazkovo.

		// 		// memset(curr_cont, 0, rec->width * rec->height * sizeof(lu_value));

		// 		//cont_perc_calc(curr_cont, prev, curr, next);
		// 	} 
		// }


		// Zbuduvaty neus dlia percepciy

		// Zbuduvaty neus dlia neus percepciy 



		//arr_each_with_index_1p(story->blocks, save_wave_each_block_save, self);

		return (Wave) wave;
	}

	mv_setup Save_Resp lu_story_save(Story self, Save_Opts opts)
	{
		lu_user_assert(self, "Story is NULL");
		lu_user_assert(opts, "Save_Opts is NULL");

		Wave wave = lu_story_save_async(self, opts);
		
		lu_wave_join(wave);

		return (Save_Resp) lu_wave_response(wave);
	}

	Wave lu_story_find_async(Story self, Find_Opts opts)
	{
		lu_user_assert(self, "Story is NULL");
		lu_user_assert(opts, "Find_Opts is NULL");

		Gate gate = brain_gate(self->brain);

		Find_Wave wave = gate_find_wave_wait(gate);

		find_wave_init(wave, self, opts);

		find_wave_process(wave);

		return (Wave) wave;
	}

	Find_Resp lu_story_find(Story self, Find_Opts opts)
	{
		lu_user_assert(self, "Story is NULL");
		lu_user_assert(opts, "Find_Opts is NULL");

		Wave wave = lu_story_find_async(self, opts);
		
		lu_wave_join(wave);

		return (Find_Resp) lu_wave_response(wave);
	}

	Wave lu_story_restore_async(Brain brain, Neuron neuron, Restore_Opts opts)
	{ 
		lu_user_assert(brain, "Brain is NULL");
		lu_user_assert(neuron, "Neuron is NULL");
		lu_user_assert(opts, "Restore_Opts is NULL");

		Gate gate = brain_gate(brain);

		Restore_Wave wave = gate_restore_wave_wait(gate);

		restore_wave_init(wave, brain, opts);

		restore_wave_process(wave);

		return (Wave) wave;
	}

	Restore_Resp lu_story_restore(Brain brain, Neuron neuron, Restore_Opts opts)
	{
		lu_user_assert(brain, "Brain is NULL");
		lu_user_assert(neuron, "Neuron is NULL");
		lu_user_assert(opts, "Restore_Opts is NULL");

		Wave wave = lu_story_restore_async(brain, neuron, opts);
		
		lu_wave_join(wave);

		return (Restore_Resp) lu_wave_response(wave);
	}

