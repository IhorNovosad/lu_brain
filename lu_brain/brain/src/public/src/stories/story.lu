/**
	Copyright Â© 2020 Oleh Ihorovych Novosad 
*/
 
///////////////////////////////////////////////////////////////////////////////
// Create and destroy

	Story story_create(Brain brain)
	{
		Story self 		= (Story) mem_alloc(g_mem_temp, sizeof(struct story));

		// Initialize
		self->brain 	= brain;
		self->blocks 	= arr_create(g_mem_temp, STORY_INITIAL_BLOCKS_SIZE);
		self->state 	= SS_BLOCK_ENDED;

		return self;
	}

	void story_each_block_destroy(lu_p_void item)
	{
		Block block = (Block) item;
		block_destroy(block);
	}

	void story_destroy(Story self)
	{
		arr_each(self->blocks, story_each_block_destroy);
		arr_destroy(self->blocks, g_mem_temp);
		mem_free(g_mem_temp, (lu_p_byte) self);
	}

///////////////////////////////////////////////////////////////////////////////
// API

	void story_push(Story self, Rec rec, lu_value* data)
	{
		if (self == NULL) lu_user_throw("self should not be NULL");
		if (rec == NULL) lu_user_throw("rec should not be NULL");
		if (data == NULL) lu_user_throw("data should not be NULL");

		Block block;

		if (self->state == SS_BLOCK_ENDED) 
		{
			block = block_create(self);
			arr_append(self->blocks, block);
		}
		else 
		{
			block = arr_last(self->blocks);
		}

		block_append(block, rec, data);
	}

	Save_Resp story_save(Story self, Save_Opts opts)
	{
		// https://www.geeksforgeeks.org/multithreading-c-2/
		Lu_Wave wave = story_save_async(self, opts);
		while (wave_is_working(wave)) sleep(1);
		return (Lu_Save_Resp) wave_response(wave);
	}

	Wave story_save_async(Story self, Save_Opts opts)
	{

	}

	Find_Resp story_find(Story self, Find_Opts opts)
	{

	}

	Wave story_find_async(Story self, Find_Opts opts)
	{

	}

	Restore_Resp story_restore(Neto neuron, Restore_Opts opts)
	{

	}

	Wave story_restore_async(Neto neuron, Restore_Opts opts)
	{ 

	}