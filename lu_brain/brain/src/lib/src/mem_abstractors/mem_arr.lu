/**
	Copyright Â© 2020 Oleh Ihorovych Novosad 
*/

 
 	lu_flags mem_arr_type_internal(Mem self);
	lu_p_byte mem_arr_alloc_internal(Mem mem, lu_size size, const char* file, int line);
	lu_p_byte mem_arr_realloc_internal(Mem mem, lu_p_byte p, lu_size size_in_bytes, const char* file, int line);
	void mem_arr_free_internal(Mem mem, lu_p_byte item, const char* file, int line);
	void mem_arr_destroy_internal(Mem mem, Mem parent_mem, const char* file, int line);

///////////////////////////////////////////////////////////////////////////////
// Inits, create and destroy

	Mem_Arr mem_arr_create (
		Mem 			mem, 
		lu_size 		item_size, 
		lu_size 		size, 
		lu_value 		percent,
		lu_flags 		flags
	)
	{
		if (item_size == 0) return NULL;

		if (size == 0 && percent == 0) return NULL;

		if (percent > 100.0) return NULL;

		// if its not preallocated mem, size should be provided
		if (size == 0 && !(mem_type(mem) & MEM_TYPE_PREALLOCATED)) return NULL;

		if (size == 0 && percent > 0)
		{
			// x * ps + x * is + sisa = a
			// x * (ps + is) = a - sisa
			// x = (a - sisa)/(ps + is)

			lu_size a = mem_preallocated_avail((Mem_Preallocated) mem) * percent  / 100.0;

			lu_size fis = item_size;
			if (flags & MEM_ARR_ITEM_FREEABLE) 
				fis += sizeof(lu_p_byte);

			size = (a - sizeof(struct mem_arr)) / fis;
		}

		lu_size full_size = sizeof(struct mem_arr) + item_size * size;
		
		if (flags & MEM_ARR_ITEM_FREEABLE) 
			full_size += sizeof(lu_p_byte) * size;


		lu_p_byte start = mem_alloc(mem, full_size);

		if (start == NULL) return NULL;

		Mem_Arr self 			= (Mem_Arr) start;

		// super
		self->super.type 		= mem_arr_type_internal;
		self->super.alloc 		= mem_arr_alloc_internal;
		self->super.realloc 	= mem_arr_realloc_internal;
		self->super.free 		= mem_arr_free_internal;
		self->super.destroy 	= mem_arr_destroy_internal;

		// other
		self->item_size 		= item_size;
		self->size 				= size;
		self->flags 			= flags;
		self->items_start 		= start + sizeof(struct mem_arr);
		self->items_pos			= self->items_start;
		self->items_end			= self->items_start + self->size * self->item_size;
		self->free_start 		= (lu_p_byte*) self->items_end;
		self->items_count 		= 0;
		self->free_count		= 0;

		return self;
	}

///////////////////////////////////////////////////////////////////////////////
// Main methods

	lu_flags mem_arr_type_internal(Mem self)
	{
		return MEM_TYPE_PREALLOCATED;
	}

	lu_p_byte mem_arr_alloc_internal(Mem mem, lu_size size, const char* file, int line)
	{
		// for Mem_Arr size of allocated items is the same each time, 
		// so we don't need to pass size other than 0. If you passed non-zero
		// value - probably you are doing something wrong.
		lu_assert(size == 0);

		Mem_Arr self = (Mem_Arr) mem;

		lu_p_byte res;
		if (self->items_pos < self->items_end)
		{
			res = self->items_pos;
			self->items_pos += self->item_size;
		}
		else 
		{
			if (self->free_count <= 0)
				return NULL; // out of available memory

			res = self->free_start[--self->free_count];
		}

		++self->items_count;

		return res;
	}

	lu_p_byte mem_arr_realloc_internal(Mem mem, lu_p_byte p, lu_size size_in_bytes, const char* file, int line)
	{
		lu_debug_message("MEM_ARR REALLOC?");
	}

	void mem_arr_free_internal(Mem mem, lu_p_byte item, const char* file, int line)
	{
		Mem_Arr self = (Mem_Arr) mem;

		if (item == NULL) return;  // should prob debug this

		if (!(self->flags & MEM_ARR_ITEM_FREEABLE)) return;

		lu_assert(self->items_count > 0);
		lu_assert(self->free_count < self->size); 

		self->free_start[self->free_count++] = item;

		--self->items_count;
	}

	void mem_arr_destroy_internal(Mem self, Mem parent_mem, const char* file, int line)
	{
		mem_free(parent_mem, (lu_p_byte) self);
	}

