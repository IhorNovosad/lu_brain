/**
	Copyright Â© 2020 Oleh Ihorovych Novosad 
*/

#include "save/save_opts.lu"
#include "save/save_resp.lu"

///////////////////////////////////////////////////////////////////////////////
// W_Save_Create_Opts

	static void save_wave_create_opts_init(W_Save_Create_Opts self)
	{
		self->blocks_max_size = 16;
	}

///////////////////////////////////////////////////////////////////////////////
// W_Save

	static W_Save w_save_create(Gate gate, S_Mem s_mem, N_Mem n_mem, W_Save_Create_Opts opts)
	{
		lu_user_assert(opts->blocks_max_size > 0, "Option blocks_max_size should be greater than 0");
		lu_user_assert(gate, "Gate is NULL");

		Lu_Brain brain = gate->brain;

		lu_user_assert(brain, "Lu_Brain is NULL");

		Mem mem = brain->header_mem;

		lu_user_assert(mem, "Mem is NULL");

		W_Save self 		= (W_Save) mem_alloc(mem, sizeof(struct w_save));
		lu_user_assert(self, "Cannot allocate W_Save");

		wave_init(&self->super, gate, s_mem, n_mem);

		return self;
	}

	static void w_save_init_and_reset(W_Save self, Lu_Story story, Lu_Save_Opts opts)
	{
		lu_user_assert_void(story, "Lu_Story is NULL");
		lu_user_assert_void(opts, "Lu_Save_Opts is NULL");

		self->super.story 	= story; 
		self->opts 			= *opts;
	} 

	// static inline data_get(

	// static void data_debug(lu_p_value data, S_Rec s_rec)
	// {
	// 	lu_size x;
	// 	lu_size y;
	// 	lu_value val;
	// 	lu_size w = s_rec->cells_w;
	// 	lu_size	h = s_rec->cells_h; 

	// 	for(y = 0; y < h; y++)
	// 		for(x = 0; w; x++)
	// 		{
	// 			val = lu_data_get(data, w, h, lu_size d, lu_size x, lu_size y, lu_size z)
	// 		}
	// }

	static void w_save(W_Save self, S_Rec s_rec, Data data, lu_size block_i)
	{
		lu_user_assert_void(self, "Lu_Wave is NULL");
		lu_user_assert_void(s_rec, "S_Rec is NULL");
		lu_user_assert_void(s_rec->rec, "S_Rec rec is NULL");
		lu_user_assert_void(data, "Data is NULL");
		lu_user_assert_void(block_i < s_rec->blocks_size, "Reached block maximum");

		lu_size x;
		lu_size y;
		lu_size z;
		lu_value v;
		lu_value p;
		lu_value contrast 		= self->opts.contrast;
		lu_bool ignore_color 	= self->opts.ignore_color;

		S_Neu s_v_cell;
		S_Neu s_p_cell;
		// S_Col s_v_col; 
		// S_Col s_p_col;
		S_Layer v_layer 	= &s_rec->v_layers[0];
		S_Layer p_layer 	= &s_rec->p_layers[0];

		N_Mem n_mem 		= self->super.n_mem;
		lu_size p_neu_ix;

		for (y = 0; y < data->h; y++)
			for(x = 0; x < data->w; x++)
			{
				s_v_cell = s_layer_neu_get(v_layer, x, y, 0);
				lu_user_assert_void(s_v_cell, "S_Cell is NULL");

				for(z = 0; z < data->d; z++)
				{
					v = data_get(data, x, y, z);

					// s_v_col = s_neu_col_get(s_v_cell, z);

					// p = s_col_p_get(s_v_col, v);

					// if (p >= contrast)
					// {
					// 	s_p_cell 	= s_layer_neu_get(p_layer, x, y);
					// 	s_p_col 	= s_neu_col_get(s_p_cell, z);

					// 	// p_neu_ix 	= s_col_get_or_create(s_p_col, n_mem, p);


					// }
				}
			}
	}