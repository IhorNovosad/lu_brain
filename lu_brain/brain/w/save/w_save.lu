/**
	Copyright Â© 2020 Oleh Ihorovych Novosad 
*/

///////////////////////////////////////////////////////////////////////////////
// W_Save_Create_Opts

	static void save_wave_create_opts_init(W_Save_Create_Opts self)
	{
		self->blocks_max_size = 16;
	}

///////////////////////////////////////////////////////////////////////////////
// W_Save

	static void w_save_init(W_Save self, Lu_Story story, Lu_Save_Opts opts)
	{
		if (opts)
			self->save_opts = *opts;

		self->super.story = story;
	} 

	static void w_save_reset(W_Save self)
	{
		lu_user_assert_void(self, "Lu_Wave is NULL");
		lu_user_assert_void(self->super.gate, "Gate is NULL");

		Lu_Brain brain = self->super.gate->brain;

		lu_user_assert_void(brain, "Lu_Brain is NULL");
		lu_user_assert_void(arr_count(brain->recs) > 0, "Lu_Brain has no recs");

		for (lu_size rec_i = 0; rec_i < arr_count(brain->recs); rec_i++)
			self->fill_data[rec_i] = NULL;
	}

	static W_Save w_save_create(Gate gate, W_Save_Create_Opts opts)
	{
		lu_user_assert(opts->blocks_max_size > 0, "Option blocks_max_size should be greater than 0");
		lu_user_assert(gate, "Gate is NULL");

		Lu_Brain brain = gate->brain;

		lu_user_assert(brain, "Lu_Brain is NULL");

		Mem mem = brain->mem_perm;

		lu_user_assert(mem, "Mem is NULL");

		W_Save self 		= (W_Save) mem_alloc(mem, sizeof(struct w_save));

		//hwave_init(&self->super, gate);

		// lu_user_assert(self, "Unable to allocate W_Save");

		// lu_user_assert(arr_count(brain->recs) > 0, "Lu_Brain has no recs");

		// self->fill_data = (lu_p_value*) mem_alloc(mem, sizeof(lu_p_value*) * arr_count(brain->recs));

		// w_save_reset(self);

		return self;
	}

	// static inline bool w_rec_pos_valid(W_Rec self, int x, int y)
	// {
	// 	return x >= 0 && x < self->w_cols_w && y >= 0 && y < self->w_cols_h; 
	// }

	static void w_save_data_send(W_Save self, Lu_Save_Opts opts, S_Rec s_rec, lu_p_value data, lu_size block_i)
	{
		lu_user_assert_void(self, "Lu_Wave is NULL");
		lu_user_assert_void(s_rec, "S_Rec is NULL");
		lu_user_assert_void(s_rec->rec, "S_Rec rec is NULL");
		lu_user_assert_void(data, "Data is NULL");


		// Lu_Wave wave 		= &self->super;

		// W_Rec w_rec 		= wave_w_rec_get(wave, s_rec->id);
		// lu_user_assert_void(w_rec, "W_Rec is NULL");

		// // W_Col p_w_col 		= NULL;
		// // W_Col c_w_col1 		= NULL;
		// // W_Col c_w_col2 		= NULL;

		// // S_Col p_n_col		= NULL;
		// // S_Col c_n_col1  		= NULL;
		// // S_Col c_n_col2		= NULL;

		// lu_size data_w 		= s_rec->rec->width;
		// lu_size data_h 		= s_rec->rec->height;

		// lu_value val_comp_size = (lu_value) w_rec->component_size;

		// // ce ne zovsim pravylno, bo kozhna s_cell takozh mozhe maty t perep,
		// // tomu odnakovo treba proytysia po vsih 

		// lu_size x, y, j, dx, dy;
		// S_Cell s_cell = NULL;

		// lu_value v;

		// if (block_i == 0) 
		// {
		// 	// zmin po chasu nema, tomu mo
		// }

		// // prohodymsia po vsih prostorovyh perepadah, obchysluyemo yih
		// // (yaksho block_i != 0 obchysluyemo chasovi perepady)
		// // paralelno formuyemo chetvirky dlia perepadiv (2 i 4)
		// // pochynayemo buduvaty piramidy dlia kozhnoyi hrupy chetvirok (yaksho v niy ye hocha b odyn neu)

		// for (y = 0; y < s_rec->cells_h; y++)
		// 	for (x = 0; x < s_rec->cells_w; x++)
		// 	{
		// 		// s_cell = s_rec_v_cell_get(s_rec, x, y);

		// 		// // lu_debug("\n s_cell (%d, %d)", x, y);
		// 		// // lu_user_assert_void(s_cell, "S_Col is NULL");

		// 		// if (s_cell == NULL) continue;

		// 		// dx = s_cell->x;
		// 		// dy = s_cell->y;

		// 		// for (j = 0; j < s_rec->component_size; j++)
		// 		// {
		// 		// 	v = lu_data_get(data, data_w, data_h, s_rec->component_size, dx, dy, j);
		// 		// }	

				
		// 	} 


		// for (y = 0; y < w_rec->w_cols_h; y++)
		// 	for (x = 0; x < w_rec->w_cols_w; x++)
		// 	{

		// 		col = w_rec_w_cols_get(w_rec, x, y);

		// 		for (j = 0; j < w_rec->component_size; j++)
		// 		{
		// 			lu_debug("\n TTT: %d, %d, %d, %d", x, y, data_w, data_h);
		// 			v = lu_data_get(data, data_w, data_h, w_rec->component_size, col->x, col->y, j);
		// 			///col->curr_vals[j] = v;
		// 		}	

				// p_w_col = arr_get(w_rec->pers, i);

				// lu_user_assert_void(p_w_col, "w_col is NULL");
				// lu_user_assert_void(p_w_col->type == SCT_PER_HOR || p_w_col->type == SCT_PER_VER, "Something went wrong");

				// if (p_w_col->type == SCT_PER_HOR)
				// {
				// 	x1 = p_w_col->x - 1;
				// 	y1 = p_w_col->y;

				// 	x2 = p_w_col->x + 1;
				// 	y2 = p_w_col->y;

				// 	c_w_col1 = w_rec_w_cols_get(w_rec, x1, y1);
				// 	c_w_col2 = w_rec_w_cols_get(w_rec, x2, y2);
				// }
				// else
				// {
				// 	x1 = p_w_col->x;
				// 	y1 = p_w_col->y - 1;

				// 	x2 = p_w_col->x;
				// 	y2 = p_w_col->y + 1;

				// 	c_w_col1 = w_rec_w_cols_get(w_rec, x1, y1);
				// 	c_w_col2 = w_rec_w_cols_get(w_rec, x2, y2);
				// }

				// lu_user_assert_void(c_w_col1 && c_w_col1->type == SCT_COL, "Something went wrong");
				// lu_user_assert_void(c_w_col2 && c_w_col2->type == SCT_COL, "Something went wrong");

				// for (j = 0; j < w_rec->component_size; j++)
				// {
				// 	v1 = lu_data_get(data, data_w, data_h, w_rec->component_size, c_w_col1->x, c_w_col1->y, j);
				// 	v2 = lu_data_get(data, data_w, data_h, w_rec->component_size, c_w_col2->x, c_w_col2->y, j);

				// 	vp[j] = lu_value_abs(v1 - v2);
				// 	vpsum += vp[j];
				// }

				// if ((vpsum / val_comp_size) >= opts->contrast)
				// {
				// 	p_n_col		= s_rec_v_cell_get(s_rec, p_w_col->x, p_w_col->y);
				// 	c_n_col1 	= s_rec_v_cell_get(s_rec, c_w_col1->x, c_w_col1->y);
				// 	c_n_col2 	= s_rec_v_cell_get(s_rec, c_w_col2->x, c_w_col2->y);


				// 	//n_ent = s_col_n_get(s_cell, value);
				// }
			// }

		// porahuvaty potochni __val__ dlia vsih w_col
		// porahuvaty perepady dlia vsih w_col z prev
		// tilky dlia perepadiv po chasu i prostoru znayty c i p neus i sformuvaty t-neu
		// for(y = 0; y < w_rec->pers_h; y++)
		// 	for(x = 0; x < w_rec->pers_w; x++)
		// 	{
		// 		w_col = w_rec_pers_get(w_rec, x, y);
		// 		lu_user_assert_void(w_col, "W_Col is NULL");
				
		// 		// for(z = 0; z < w_rec->component_size; z++)
		// 		// {
		// 		// 	// we are assuming data sizes and w_rec->pers sizes are the same
		// 		// 	value = lu_data_get(data, data_w, data_h, w_rec->component_size, x, y, z);

		// 		// 	//w_col->curr_vals[z] = value;
		// 		// }
		// 	}


				// 		s_cell = n_rec_pers_get(s_rec, x, y);
		// 		lu_user_assert_void(s_cell, "S_Col is NULL");

		// 		for(z = 0; z < s_rec->component_size; z++)
		// 		{
		// 			value = lu_data_get(data, s_rec->pers_w, s_rec->pers_h, s_rec->component_size, x, y, z);

		// 			n_ent = s_col_n_get(s_cell, value);
		// 			lu_user_assert_void(n_ent, "Cannot get n_ent for value");

		// 			//save_wave_c_neu_fire(self, n_ent, value);
	}

	static void w_save_rec_progress(W_Save wave, S_Rec s_rec, lu_size block_i)
	{

	}

	static void w_save_block_progress(W_Save wave, lu_size block_i)
	{

	}