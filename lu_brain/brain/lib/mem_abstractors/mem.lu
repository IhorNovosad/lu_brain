/**
	Copyright Â© 2020 Oleh Ihorovych Novosad 
*/
 
///////////////////////////////////////////////////////////////////////////////
// Mem (default)

	lu_p_byte mem_alloc_default(Mem self, lu_size size, const char* func, const char* file, int line)
	{
		// Mem specific debug here

		// I am using calloc instead of malloc here for easier debugging 
		// changing to malloc should not change program behavior
		return (lu_p_byte) calloc(1, size);
	}

	lu_p_byte mem_realloc_default(Mem self, lu_p_byte p, lu_size size_in_bytes, const char* func, const char* file, int line)
	{
		// Mem specific debug here

		return (lu_p_byte) realloc(p, size_in_bytes);
	}

	void mem_free_default(Mem self, lu_p_byte p, const char* func, const char* file, int line)
	{
		// Mem specific debug here

		free((lu_p_void) p);
	}

	void mem_destroy_default(Mem self, Mem parent_mem, const char* func, const char* file, int line)
	{
		// Mem specific debug here

		free((lu_p_void) self);
	}

	Mem_Table mem_table_create_default(
		Mem 		mem, 
		lu_size 	record_size_in_bytes, 
		lu_size 	table_size_in_records, 
		lu_value 	percent,
		lu_flags 	flags,
		const char* func, 
		const char* file,
		int line
	);

///////////////////////////////////////////////////////////////////////////////
// Globals

	struct mem g_mem_default_instance = {
		.alloc 			= mem_alloc_default,
		.realloc 		= mem_realloc_default,
		.free 			= mem_free_default,
		.destroy 		= mem_destroy_default,
		.table_create 	= mem_table_create_default
	};

	Mem g_mem_temp = &g_mem_default_instance;

///////////////////////////////////////////////////////////////////////////////
// Inits, create and destroy

	void mem_init(Mem self)
	{
		self->alloc 		= g_mem_default_instance.alloc;
		self->realloc 		= g_mem_default_instance.realloc;
		self->free 			= g_mem_default_instance.free;
		self->destroy 		= g_mem_default_instance.destroy;
		self->table_create 	= g_mem_default_instance.table_create;
	}

	Mem mem_create()
	{
		Mem self 		= malloc(sizeof(struct mem));

		mem_init(self);

		return self;
	}

///////////////////////////////////////////////////////////////////////////////
// Mem_Table

    void mem_table_realloc_default(
		Mem_Table self, 
		lu_size new_size_in_bytes, 
		lu_flags flags, 
		const char* func, 
		const char* file, 
		int line
	)
	{
		lu_debug_message("NOT IMPLEMENTED");
	}

	void mem_table_destroy_default(Mem_Table self, Mem mem, const char* func, const char* file, int line)
	{
		mem_free(mem, (lu_p_byte) self);
	}
	
	lu_p_byte mem_table_record_alloc_default(Mem_Table self, const char* func, const char* file, int line)
	{
		lu_p_byte res;
		if (self->records_pos < self->records_end)
		{
			res = self->records_pos;
			self->records_pos += self->record_size_in_bytes;
		}
		else 
		{
			if (self->free_count <= 0)
			{
				lu_user_debug_internal(func, file, line, "MEM_TABLE allocation failed");
				return NULL; // out of available memory
			}
			res = self->free_start[--self->free_count];
		}

		++self->records_count;

		return res;
	}

	void mem_table_record_free_default(Mem_Table self, lu_p_byte record, const char* func, const char* file, int line)
	{
		if (record == NULL) return;  // should prob debug this

		if (!(self->flags & MEM_TABLE_CAN_FREE_ITEMS)) return;

		lu_assert(self->records_count > 0);
		lu_assert(self->free_count < self->table_size_in_records); 

		self->free_start[self->free_count++] = record;

		--self->records_count;
	}

	Mem_Table mem_table_create_default(
		Mem 		mem, 
		lu_size 	record_size_in_bytes, 
		lu_size 	table_size_in_records, 
		lu_value 	percent,
		lu_flags 	flags,
		const char* func, 
		const char* file,
		int line
	)
	{
		if (record_size_in_bytes == 0) return NULL;

		if (table_size_in_records == 0) return NULL;

		if (percent > 100.0) return NULL;

		lu_size full_size = sizeof(struct mem_table) + record_size_in_bytes * table_size_in_records;
		
		if (flags & MEM_TABLE_CAN_FREE_ITEMS) 
			full_size += sizeof(lu_p_byte) * table_size_in_records;

		lu_p_byte start = mem_alloc(mem, full_size);

		if (start == NULL) return NULL;

		Mem_Table self 				= (Mem_Table) start;

		self->realloc 				= mem_table_realloc_default;
		self->destroy 				= mem_table_destroy_default;
		self->record_alloc 			= mem_table_record_alloc_default;
		self->record_free 			= mem_table_record_free_default;

		self->record_size_in_bytes 	= record_size_in_bytes;
		self->table_size_in_records = table_size_in_records;
		self->flags 				= flags;
		self->records_start 		= start + sizeof(struct mem_table);
		self->records_pos			= self->records_start;
		self->records_end			= self->records_start + self->table_size_in_records * self->record_size_in_bytes;
		self->free_start 			= (lu_p_byte*) self->records_end;
		self->records_count 		= 0;
		self->free_count			= 0;

		return self;
	}