/**
	Copyright Â© 2020 Oleh Ihorovych Novosad
*/
 
///////////////////////////////////////////////////////////////////////////////
// Structs and types

///////////////////////////////////////////////////////////////////////////////
// Prototypes
 
///////////////////////////////////////////////////////////////////////////////
// Create and destroy

Arr arr_create(Mem mem, lu_size size)
{
	lu_assert(size > 0);
	lu_assert(mem != NULL);

	Arr self = (Arr) mem_alloc(mem, sizeof(struct arr));
	
	// Initialize
	self->size 			= size;
	self->count 		= 0;
	self->items 		= (lu_p_void*) mem_alloc(mem, self->size * sizeof(lu_p_void));

	return self;
}

void arr_destroy(Arr self, Mem mem)
{
	mem_free(mem, (lu_p_byte) self->items);
	mem_free(mem, (lu_p_byte) self);
}

///////////////////////////////////////////////////////////////////////////////
// Main public methods

lu_size arr_append(Arr self, lu_p_void item)
{
	lu_assert(self != NULL);
	lu_assert(self->count < self->size);
 
 	// no automatic realloc 
	// if (self->count >= self->size) 
		// arr_realloc(self, self->size * 2);

	
	lu_size index = self->count;

	self->items[self->count] = item;
	++self->count;

	return index;
}

void arr_each(Arr self, void (*block)(lu_p_void item))
{
	for (lu_size i = 0; i < self->count; i++)
	{
		block((void *) self->items[i]);
	}
}

void arr_each1(Arr self, void (*block)(lu_p_void item, lu_p_void p1), lu_p_void p1)
{
	for (lu_size i = 0; i < self->count; i++)
	{
		block((lu_p_void) self->items[i], p1);
	}
}

void arr_each_1p(Arr self, void (*block)(lu_p_void item, lu_p_void p1), lu_p_void p1)
{
	for (lu_size i = 0; i < self->count; i++)
	{
		block((lu_p_void) self->items[i], p1);
	}
}

void arr_each_2p(Arr self, void (*block)(lu_p_void item, lu_p_void p1, lu_p_void p2), lu_p_void p1, lu_p_void p2)
{
	for (lu_size i = 0; i < self->count; i++)
	{
		block((lu_p_void) self->items[i], p1, p2);
	}
}

void arr_each_with_index_1p(Arr self, void (*block)(Arr self, lu_p_void item, lu_size index, lu_p_void p1), lu_p_void p1)
{
	for (lu_size i = 0; i < self->count; i++)
	{
		block(self, (lu_p_void) self->items[i], i, p1);
	}
}


void arr_nullify(Arr self)
{ 
	for (lu_size i = 0; i < self->size; i++)
	{
		self->items[i] = NULL;
	}
}

void arr_realloc(Arr self, lu_size new_size, Mem mem)
{
	lu_assert(new_size > self->size);

	self->size = new_size;

	self->items = (lu_p_void*) mem_realloc(mem, (lu_p_byte) self->items, sizeof(lu_p_void) * self->size);
	lu_assert(self->items != NULL);
}

Arr arr_merge(Arr self, Arr src)
{
	lu_assert(self->count + src->count < self->size);

	// no automatic realloc
	// if (self->count + src->count > self->size)
	// 	arr_realloc(self, self->count + src->count);

	for(lu_size i = 0; i < src->count; i++)
		self->items[self->count++] = src->items[i];

	return self;
} 

lu_p_void arr_find_first_1p(Arr self, bool (*block)(lu_p_void item, lu_p_void p1), lu_p_void p1)
{
	lu_p_void item;
	for(lu_size i = 0; i < self->count; i++) 
	{
		item = self->items[i];
		if (block(item, p1)) return item;
	}

	return NULL;
}

///////////////////////////////////////////////////////////////////////////////
// Other public methods
